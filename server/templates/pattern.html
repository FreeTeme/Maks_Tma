<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT — Поиск паттернов</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-0: #0f1419;
            --bg-1: #11161c;
            --bg-2: #131a21;
            --bg-3: #0b1015;
            --panel: #0f151b;
            --border: #1c2631;
            --muted: #8b99a8;
            --text: #e5edf5;
            --accent: #f7931a;
            --green: #22c55e;
            --red: #ef4444;
        }

        html, body { 
            height: 100%; 
            margin: 0;
            padding: 0;
        }
        body {
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 600px at 20% -10%, #0b1117 0%, #0a0f14 45%, #070b0f 100%);
            color: var(--text);
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(17,22,28,0.85), rgba(17,22,28,0.65));
            backdrop-filter: blur(6px);
            flex-shrink: 0;
            flex-wrap: wrap; /* Добавляем перенос на мобильных */
            gap: 10px; /* Добавляем отступы между элементами */
        }

        .brand { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            flex-shrink: 0;
        }

        .kpis { 
            display: flex; 
            gap: 12px; 
            align-items: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        /* Добавляем контейнер для выбора символа */
        .symbol-selector {
            margin-left: 15px;
            flex-shrink: 0;
        }

        .symbol-select {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            min-width: 120px;
        }

        .symbol-select option {
            background: var(--bg-2);
            color: var(--text);
        }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .panel { 
            background: var(--panel); 
            border: 1px solid var(--border); 
            border-radius: 12px; 
            overflow: hidden;
            flex: 1;
            margin: 12px;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, var(--bg-2), var(--bg-3));
            flex-shrink: 0;
        }
        .left-tools, .right-tools { display: flex; gap: 6px; align-items: center; }
        .left-tools { justify-content: space-between; width: 100%; flex-wrap: wrap; }
        .right-tools { flex-wrap: nowrap; }
        .btn {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.15s ease;
            white-space: nowrap;
        }
        .tf .btn { flex: 1; }
        .btn:hover { background: #212a34; }
        .btn.primary { background: var(--accent); border-color: #ffb547; color: #0c0f12; font-weight: 600; }
        .btn.primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.analyze { 
            background: #22c55e !important; 
            border-color: #16a34a !important; 
            color: #ffffff !important; 
            font-weight: 600; 
            padding: 8px 12px; 
            font-size: 13px; 
        }
        .btn.analyze:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            background: #22c55e !important; 
        }
        .btn.analyze:hover { 
            background: #16a34a !important; 
            border-color: #15803d !important;
        }
        .btn.clear { 
            background: #dc2626 !important; 
            border-color: #b91c1c !important; 
            color: #ffffff !important; 
            font-weight: 600; 
        }
        .btn.clear:hover { 
            background: #b91c1c !important; 
            border-color: #991b1b !important;
        }
        .tf { display: flex; gap: 6px; flex: 1; }
        .tf .btn.active { background: #2a3542; border-color: #334153; }
        .sep { width: 1px; height: 22px; background: var(--border); }
        .counter { font-size: 12px; color: var(--muted); }
        .counter strong { color: var(--text); }

        .chart-wrap { 
            position: relative; 
            flex: 1; 
            min-height: 300px; 
        }
        #chart { 
            width: 100%; 
            height: 100%; 
            touch-action: pan-x pan-y pinch-zoom;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .side {
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 0 12px 60px;
            overflow-y: auto;
        }
        .side.active {
            display: flex;
        }
        .card { 
            background: var(--panel); 
            border: 1px solid var(--border); 
            border-radius: 10px; 
            padding: 10px; 
        }
        .card h3 { margin: 0 0 6px; font-size: 13px; color: var(--muted); font-weight: 600; }
        .stat-list { display: grid; gap: 6px; }
        .stat { display: flex; justify-content: space-between; font-size: 12px; }
        .stat .val { color: var(--text); font-weight: 600; }

        .matches { display: grid; gap: 8px; }
        .match {
            border: 1px solid var(--border);
            border-radius: 8px; 
            padding: 8px;
            background: #0f151b;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .match:hover { 
            background: #131a21; 
            border-color: #2a3847; 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .match::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        .match:hover::before {
            left: 100%;
        }
        .match.active {
            background: linear-gradient(135deg, #1a222c, #131a21);
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(247, 147, 26, 0.3);
            transform: translateY(-2px);
        }
        .match.active::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--accent);
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Индикатор активных выбранных свечей */
        .selected-candles-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 6px 16px rgba(255, 107, 53, 0.6); }
            100% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4); }
        }
        .match .hdr { display: flex; justify-content: space-between; align-items: center; }
        .match .range { font-size: 11px; color: var(--muted); }
        .badge { 
            padding: 4px 8px; 
            border-radius: 999px; 
            font-size: 11px; 
            font-weight: 700; 
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        .badge.up { 
            background: linear-gradient(135deg, rgba(34,197,94,0.2), rgba(34,197,94,0.1)); 
            color: var(--green); 
            border-color: rgba(34,197,94,0.3);
            box-shadow: 0 2px 8px rgba(34,197,94,0.2);
        }
        .badge.down { 
            background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(239,68,68,0.1)); 
            color: var(--red); 
            border-color: rgba(239,68,68,0.3);
            box-shadow: 0 2px 8px rgba(239,68,68,0.2);
        }

        .footer-note { font-size: 11px; color: var(--muted); text-align: center; padding-top: 4px; }
        
        /* Общий анализ паттернов */
        .pattern-distribution {
            margin: 12px 0;
            display: grid;
            gap: 8px;
        }
        
        .distribution-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .distribution-label {
            flex: 1;
            color: var(--muted);
            font-weight: 500;
        }
        
        .distribution-bar {
            flex: 2;
            height: 8px;
            background: var(--bg-2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .distribution-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.8s ease;
            position: relative;
        }
        
        .distribution-fill.bullish {
            background: linear-gradient(90deg, #22c55e, #16a34a);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);
        }
        
        .distribution-fill.bearish {
            background: linear-gradient(90deg, #ef4444, #dc2626);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.3);
        }
        
        .distribution-value {
            min-width: 30px;
            text-align: right;
            color: var(--text);
            font-weight: 600;
            font-size: 11px;
        }
        
        /* Недавние паттерны */
        .recent-patterns {
            display: grid;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .recent-pattern {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .recent-pattern:hover {
            background: var(--bg-3);
            border-color: #334153;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .recent-pattern::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s ease;
        }
        
        .recent-pattern:hover::before {
            left: 100%;
        }
        
        .recent-pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .recent-pattern-dates {
            font-size: 11px;
            color: var(--muted);
        }
        
        .recent-pattern-direction {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .recent-pattern-direction.bullish {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        
        .recent-pattern-direction.bearish {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .recent-pattern-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }
        
        .recent-pattern-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .recent-pattern-stat-label {
            color: var(--muted);
        }
        
        .recent-pattern-stat-value {
            color: var(--text);
            font-weight: 600;
        }
        
        .recent-pattern-stat-value.positive {
            color: var(--green);
        }
        
        .recent-pattern-stat-value.negative {
            color: var(--red);
        }
        
        /* Анимация загрузки для общего анализа */
        .general-analysis-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--muted);
        }
        
        .general-analysis-loading i {
            margin-right: 8px;
            animation: spin 1s linear infinite;
        }
        
        /* Мини-график */
        .mini-chart-container {
            margin: 12px 0;
            padding: 8px;
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            text-align: center;
        }
        
        .mini-chart-container canvas {
            border-radius: 4px;
            background: var(--bg-3);
        }
        
        .mini-chart-label {
            font-size: 10px;
            color: var(--muted);
            margin-top: 4px;
            font-weight: 500;
        }
        
        /* Статистика производительности */
        .performance-summary {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            display: grid;
            gap: 8px;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .summary-label {
            color: var(--muted);
            font-weight: 500;
        }
        
        .summary-value {
            font-weight: 600;
            font-size: 13px;
        }
        
        .summary-value.bullish {
            color: var(--green);
        }
        
        .summary-value.bearish {
            color: var(--red);
        }

        
        .chart-controls {
            display: none;
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            background: rgba(17, 22, 28, 0.95);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 12px;
            z-index: 50;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        .chart-controls.visible {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }
        .chart-controls.collapsed {
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chart-controls.collapsed .control-btn {
            display: none;
        }
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 14px;
            background: #1a222c;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
            flex: 1;
        }
        .control-btn:hover {
            background: #212a34;
            border-color: #334153;
        }
        .control-btn i {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        .toggle-controls-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: var(--accent);
            border: 1px solid #ffb547;
            border-radius: 8px;
            color: #0c0f12;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            min-width: 38px;
            flex-shrink: 0;
        }
        .toggle-controls-btn:hover {
            background: #ffb547;
        }
        .chart-controls.collapsed .toggle-controls-btn {
            border-radius: 50%;
            width: 100%;
            height: 100%;
            min-width: 48px;
        }

        /* Mobile bottom navigation */
        .mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-1);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 12px 16px;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(17, 22, 28, 0.9);
        }
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 24px;
            font-size: 13px;
            color: #ffffff;
            background: none;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            font-weight: 600;
        }
        .nav-btn.active {
            color: var(--accent);
            background: rgba(247, 147, 26, 0.1);
        }
        .nav-btn i {
            font-size: 20px;
            margin-bottom: 4px;
        }
        #nav-analysis {
            background: #22c55e !important;
            border: 1px solid #16a34a;
        }
        #nav-analysis:hover {
            background: #16a34a !important;
        }
        #nav-volume {
            background: #1a222c !important;
            border: 1px solid var(--border);
        }
        #nav-volume:hover {
            background: #212a34 !important;
        }
        #nav-clear {
            background: #dc2626 !important;
            border: 1px solid #b91c1c;
        }
        #nav-clear:hover {
            background: #b91c1c !important;
        }

        /* Modal for patterns */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(7, 11, 15, 0.9);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: var(--panel);
            border-radius: 12px;
            padding: 16px;
            max-width: 500px;
            margin: 0 auto;
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }
        
        /* Clear Modal Styles */
        .clear-modal-content {
            max-width: 450px;
            text-align: center;
        }
        
        .clear-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.3);
        }
        
        .clear-icon i {
            font-size: 32px;
            color: #ffffff;
        }
        
        .clear-modal-content h3 {
            margin: 0 0 12px;
            font-size: 20px;
            font-weight: 600;
            color: var(--text);
        }
        
        .clear-modal-content p {
            margin: 0 0 24px;
            font-size: 14px;
            color: var(--muted);
            line-height: 1.5;
        }
        
        .clear-stats {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin: 0 0 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--muted);
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
        }
        
        .clear-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .btn.clear-confirm {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            border: none;
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        
        .btn.clear-confirm:hover {
            background: linear-gradient(135deg, #b91c1c, #991b1b);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        
        .btn.clear-cancel {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        
        .btn.clear-cancel:hover {
            background: var(--bg-3);
            border-color: #334153;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        .modal-title {
            font-weight: 600;
            font-size: 16px;
        }
        .close-modal {
            background: none;
            border: none;
            color: var(--muted);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .close-modal:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--red);
        }

        /* Overlay + toast */
        .loading {
            position: fixed; 
            inset: 0; 
            display: none; 
            align-items: center; 
            justify-content: center;
            background: rgba(3,6,9,0.55); 
            backdrop-filter: blur(2px); 
            z-index: 50;
        }
        .spinner { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 3px solid rgba(255,255,255,0.12); 
            border-top-color: var(--accent); 
            animation: spin 0.9s linear infinite; 
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .toast { 
            position: fixed; 
            bottom: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: #111821; 
            border: 1px solid #223041; 
            color: #e3edf7; 
            padding: 10px 14px; 
            border-radius: 10px; 
            font-size: 13px; 
            display: none; 
            z-index: 60;
            max-width: 80%;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .app {
                display: grid;
                grid-template-rows: auto 1fr;
            }
            
            .main {
                display: grid;
                grid-template-columns: 1fr 320px;
                gap: 12px;
                padding: 12px;
                overflow: hidden;
            }
            
            /* Скрываем кнопку анализа на десктопе */
            #nav-analysis-overlay {
                display: none !important;
            }
            
            .panel {
                margin: 0;
            }
            
            .side {
                display: flex;
                padding: 0;
                overflow-y: auto;
            }
            
            .mobile-nav {
                display: none;
            }
            
            .topbar {
                padding: 16px 20px;
            }
            
            .brand .logo {
                width: 28px; 
                height: 28px;
            }
            
            .brand .title {
                font-size: 16px;
            }
            
            .kpis {
                gap: 16px;
                font-size: 13px;
            }
            
            .toolbar {
                padding: 10px 12px;
            }
            
            .btn {
                padding: 8px 10px;
                font-size: 13px;
            }
        }

        @media (max-width: 768px) {
            .chart-controls {
                bottom: 80px;
            }
            
            .chart-controls.collapsed {
                bottom: 80px;
            }
            
            .control-btn span {
                display: none;
            }
            
            .control-btn {
                padding: 8px;
                min-width: 40px;
                justify-content: center;
            }
            
            /* Hide desktop action buttons on mobile (use mobile-nav instead) */
            #toggle-volume-btn, #analyze-btn, #clear-btn {
                display: none !important;
            }
        }

        @media (max-width: 380px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .left-tools, .right-tools {
                flex-wrap: wrap;
            }
            
            .btn {
                font-size: 11px;
                padding: 5px 6px;
            }
            
            .counter {
                font-size: 11px;
            }
            
            .chart-controls {
                gap: 6px;
                padding: 8px;
                left: 8px;
                right: 8px;
            }
            
            .chart-controls.collapsed {
                width: 44px;
                height: 44px;
            }
            
            .control-btn {
                padding: 6px;
                min-width: 36px;
            }
            
            .toggle-controls-btn {
                padding: 6px;
                min-width: 34px;
                font-size: 14px;
            }
            
            .chart-controls.collapsed .toggle-controls-btn {
                min-width: 44px;
            }
        }

        .symbol-selector {
            margin-left: 15px;
        }

        .symbol-select {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            min-width: 120px;
        }

        .symbol-select option {
            background: var(--bg-2);
            color: var(--text);
        }

        .update-status {
            font-size: 12px;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="topbar">
            <div class="brand">
                <div class="logo"></div>
                <!-- В разделе .brand, после .title -->
                <div class="title" id="page-title">Поиск паттернов</div>
                <div class="symbol-selector">
                    <select id="symbol-select" class="symbol-select">
                        <option value="BTC#USDT">BTC/USDT</option>
                        <option value="ETH#USDT">ETH/USDT</option>
                        <option value="XRP#USDT">XRP/USDT</option>
                        <option value="SOL#USDT">SOL/USDT</option>
                        <option value="BNB#USDT">BNB/USDT</option>
                        <option value="TRX#USDT">TRX/USDT</option>
                        <option value="ADA#USDT">ADA/USDT</option>
                        <option value="SUI#USDT">SUI/USDT</option>
                        <option value="LINK#USDT">LINK/USDT</option>
                        <option value="LTC#USDT">LTC/USDT</option>
                        <option value="TON#USDT">TON/USDT</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="main">
            <div class="panel">
                <div class="toolbar">
                    <div class="left-tools">
                        <div class="tf">
                            <button class="btn" data-tf="1h">1 час</button>
                            <button class="btn" data-tf="4h">4 часа</button>
                            <button class="btn active" data-tf="1d">1 день</button>
                            <button class="btn" data-tf="1w">1 неделя</button>
                        </div>
                        <div class="right-tools">
                            <button id="toggle-volume-btn" class="btn" title="Показать/скрыть объем">
                                <i class="fas fa-chart-bar"></i> Объем
                            </button>
                            <!-- <button id="reset-view-btn" class="btn">Сброс</button> -->
                            <button id="analyze-btn" class="btn analyze" disabled>
                                <i class="fas fa-chart-line"></i> Анализ
                            </button>
                            <button id="clear-btn" class="btn clear">
                                <i class="fas fa-trash"></i> Очистить
                            </button>
                            <!-- <button id="test-update-btn" class="btn" style="background: #8b5cf6;">
                                <i class="fas fa-bolt"></i> Тест обновления
                            </button> -->
                        </div>
                    </div>
                </div>
                <div class="chart-wrap">
                    <div id="chart"></div>
                    <!-- Chart Controls Overlay -->
                    <div class="chart-controls" id="chart-controls">
                        <button class="control-btn" id="nav-prev">
                            <i class="fas fa-chevron-left"></i>
                            <span>Назад</span>
                        </button>
                        <button class="control-btn" id="nav-next">
                            <i class="fas fa-chevron-right"></i>
                            <span>Вперед</span>
                        </button>
                        <button class="control-btn" id="nav-to-selected">
                            <i class="fas fa-search"></i>
                            <span>К выбранным</span>
                        </button>
                        <button class="control-btn" id="nav-analysis-overlay">
                            <i class="fas fa-chart-line"></i>
                            <span>Анализ</span>
                        </button>
                        <button class="control-btn" id="nav-patterns">
                            <i class="fas fa-shapes"></i>
                            <span>Паттерны</span>
                        </button>
                        <button class="toggle-controls-btn" id="toggle-controls-btn" title="Свернуть/Развернуть">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                </div>
            </div>

            <div class="side" id="side-panel">
                <!-- Общий анализ паттернов -->
                <div class="card" id="general-analysis-card">
                    <h3>Общий анализ рынка</h3>
                    <div class="stat-list" id="general-stats">
                        <div class="stat"><span>Всего свечей</span><span class="val" id="total-candles">-</span></div>
                        <div class="stat"><span>Период данных</span><span class="val" id="data-period">-</span></div>
                        <div class="stat"><span>Волатильность</span><span class="val" id="volatility">-</span></div>
                        <div class="stat"><span>Средний объем</span><span class="val" id="avg-volume">-</span></div>
                    </div>
                    <div class="pattern-distribution">
                        <div class="distribution-item">
                            <span class="distribution-label">Бычьи паттерны</span>
                            <div class="distribution-bar">
                                <div class="distribution-fill bullish" id="bullish-bar"></div>
                            </div>
                            <span class="distribution-value" id="bullish-count">0</span>
                        </div>
                        <div class="distribution-item">
                            <span class="distribution-label">Медвежьи паттерны</span>
                            <div class="distribution-bar">
                                <div class="distribution-fill bearish" id="bearish-bar"></div>
                            </div>
                            <span class="distribution-value" id="bearish-count">0</span>
                        </div>
                    </div>
                    <div class="mini-chart-container" id="mini-chart-container" style="display: none;">
                        <canvas id="mini-chart" width="280" height="80"></canvas>
                        <div class="mini-chart-label">Тренд цены (последние 30 дней)</div>
                    </div>
                    <!-- <button class="btn analyze" id="load-general-analysis" style="width: 100%; margin-top: 10px;">
                        <i class="fas fa-chart-pie"></i> Анализ выбранных свечей
                    </button> -->
                </div>
                
                <!-- Недавние паттерны -->
                <div class="card" id="recent-patterns-card" style="display:none">
                    <h3>Недавние паттерны</h3>
                    <div class="recent-patterns" id="recent-patterns-list"></div>
                </div>
                
                <div class="card">
                    <h3>Итоги анализа</h3>
                    <div class="stat-list">
                        <div class="stat"><span>Найдено совпадений</span><span class="val" id="matches-found">0</span></div>
                        <div class="stat"><span>Длина паттерна</span><span class="val" id="pattern-length">0</span></div>
                    </div>
                    <div class="footer-note">Выберите 1–6 свечей на графике и запустите анализ</div>
                </div>
                <div class="card" id="pattern-info-card" style="display:none">
                    <h3>Паттерн</h3>
                    <div class="stat-list" id="pattern-info"></div>
                </div>
                <div class="card">
                    <h3>Совпадения</h3>
                    <div class="matches" id="matches"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Navigation -->
    <div class="mobile-nav">
        <button class="nav-btn" id="nav-volume">
            <i class="fas fa-chart-bar"></i>
            <span>Объем</span>
        </button>
        <button class="nav-btn" id="nav-analysis">
            <i class="fas fa-chart-line"></i>
            <span>Анализ</span>
        </button>
        <button class="nav-btn" id="nav-clear">
            <i class="fas fa-trash"></i>
            <span>Очистить</span>
        </button>
    </div>

    <!-- Patterns Modal -->
    <div class="modal" id="patterns-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Найденные паттерны</div>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="pattern-stats" id="modal-pattern-stats" style="margin-bottom: 16px; padding: 12px; background: var(--bg-2); border-radius: 8px; border: 1px solid var(--border);">
                    <!-- Pattern statistics will be inserted here -->
                </div>
                <div id="modal-patterns-list">
                    <!-- Patterns will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Clear Confirmation Modal -->
    <div class="modal" id="clear-confirmation-modal">
        <div class="modal-content clear-modal-content">
            <div class="modal-header">
                <div class="modal-title">
                    <i class="fas fa-trash-alt" style="margin-right: 8px; color: #dc2626;"></i>
                    Очистка выбора
                </div>
                <button class="close-modal" id="close-clear-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="clear-modal-content">
                    <div class="clear-icon">
                        <i class="fas fa-sync-alt"></i>
                    </div>
                    <h3>Обновить страницу?</h3>
                    <p>Это действие обновит страницу и сбросит все выбранные свечи и анализ. Вы сможете начать заново.</p>
                    <div class="clear-actions">
                        <button class="btn clear-confirm" id="confirm-clear-btn">
                            <i class="fas fa-sync-alt"></i>
                            <span>Да, обновить</span>
                        </button>
                        <button class="btn clear-cancel" id="cancel-clear-btn">
                            <i class="fas fa-times"></i>
                            <span>Отмена</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
		// Вспомогательная функция для безопасного обновления textContent
        function safeSetTextContent(elementId, text) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = text;
            }
        }

        function safeSetInnerHTML(elementId, html) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = html;
            }
        }

        function safeSetStyle(elementId, property, value) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style[property] = value;
            }
        }

class SmartChartUpdater {
    constructor(chartInstance) {
        this.chart = chartInstance;
        this.lastKnownTimestamp = null;
        this.updateIntervals = {
            '1h': 3600000,    // 1 час
            '4h': 14400000,   // 4 часа  
            '1d': 86400000,   // 1 день
            '1w': 604800000   // 1 неделя
        };
        this.isUpdating = false;
        this.updateTimer = null;
        this.retryCount = 0;
        this.maxRetries = 2;
        this.symbol = 'BTC#USDT';
        this.timeframe = '1d';
        this.hasPerformedInitialUpdate = false;
        this.lastUpdateTime = null;
    }

    // Инициализация обновлений
    initialize(symbol, timeframe) {
        console.log(`🔄 ИНИЦИАЛИЗАЦИЯ АВТООБНОВЛЕНИЯ: ${symbol}, ${timeframe}`);
        this.symbol = symbol;
        this.timeframe = timeframe;
        
        // Устанавливаем последний известный таймстамп
        if (this.chart.allCandles && this.chart.allCandles.length > 0) {
            this.lastKnownTimestamp = this.chart.allCandles[this.chart.allCandles.length - 1].open_time;
            console.log(`📅 Последняя свеча: ${this.lastKnownTimestamp}`);
        }
        
        // ЗАПУСКАЕМ ТОЛЬКО ПЕРВИЧНУЮ ПРОВЕРКУ
        this.performInitialUpdate();
    }

    // Первичное обновление при загрузке
    async performInitialUpdate() {
        if (this.hasPerformedInitialUpdate) {
            console.log('⏭️ Первичное обновление уже выполнено, пропускаем');
            return;
        }

        console.log('🔍 ВЫПОЛНЕНИЕ ПЕРВИЧНОГО ОБНОВЛЕНИЯ...');
        
        try {
            const freshness = this.checkDataFreshness();
            console.log(`🔍 Статус свежести: ${freshness}`);
            
            if (freshness === 'stale') {
                console.log('🔄 Данные устарели, запускаем принудительное обновление...');
                await this.guaranteedDataRefresh();
            } else {
                // Если данные свежие, просто проверяем наличие небольших обновлений
                console.log('🔍 Проверка небольших обновлений...');
                const updateCheck = await this.checkForUpdates();
                
                if (updateCheck.has_updates && updateCheck.new_candles_count > 0) {
                    console.log(`🆕 Найдено обновлений: ${updateCheck.new_candles_count} свечей`);
                    await this.loadAndApplyUpdates();
                } else {
                    console.log('✅ Данные актуальны');
                }
            }
            
            this.hasPerformedInitialUpdate = true;
            this.lastUpdateTime = new Date();
            this.retryCount = 0;
            
            // ЗАПУСКАЕМ ДОЛГОСРОЧНЫЕ ОБНОВЛЕНИЯ ТОЛЬКО ПОСЛЕ ПЕРВИЧНОГО
            this.startLongTermUpdates();
            
        } catch (error) {
            console.error('❌ Ошибка в первичном обновлении:', error);
            this.hasPerformedInitialUpdate = true;
        }
    }

    // Долгосрочные обновления (редкие)
    startLongTermUpdates() {
        if (this.updateTimer) {
            clearInterval(this.updateTimer);
        }
        
        const longTermIntervals = {
            '1h': 300000,    // 5 минут
            '4h': 900000,    // 15 минут  
            '1d': 3600000,   // 1 час
            '1w': 43200000   // 12 часов
        };
        
        const interval = longTermIntervals[this.timeframe] || 3600000;
        console.log(`⏰ Запуск долгосрочных обновлений каждые ${interval/60000} минут`);
        
        this.updateTimer = setInterval(() => {
            this.smartUpdate();
        }, interval);
    }

    // Умное обновление (для долгосрочных проверок)
    async smartUpdate() {
        if (this.isUpdating) {
            console.log('⏳ Обновление уже выполняется, пропускаем...');
            return;
        }
        
        // Проверяем, не слишком ли рано для обновления
        if (this.lastUpdateTime && (Date.now() - this.lastUpdateTime < 60000)) {
            console.log('⏰ Слишком рано для обновления, пропускаем...');
            return;
        }
        
        this.isUpdating = true;
        
        try {
            console.log('🔍 Долгосрочная проверка обновлений...');
            const updateCheck = await this.checkForUpdates();
            
            if (updateCheck.has_updates && updateCheck.new_candles_count > 0) {
                console.log(`🆕 Найдено обновлений: ${updateCheck.new_candles_count} свечей`);
                await this.loadAndApplyUpdates();
            } else {
                console.log('✅ Данные актуальны (долгосрочная проверка)');
            }
            
            this.lastUpdateTime = new Date();
            this.retryCount = 0;
            
        } catch (error) {
            console.error('❌ Ошибка в долгосрочном обновлении:', error);
            this.retryCount++;
            
            if (this.retryCount >= this.maxRetries) {
                console.error('🚨 Превышено количество попыток, останавливаем автообновление');
                this.stop();
            }
        } finally {
            this.isUpdating = false;
        }
    }

    // Проверка свежести данных
    checkDataFreshness() {
        if (!this.lastKnownTimestamp) return 'unknown';
        
        const lastKnown = new Date(this.lastKnownTimestamp);
        const now = new Date();
        const diffHours = (now - lastKnown) / (1000 * 60 * 60);
        
        console.log(`⏰ Возраст данных: ${diffHours.toFixed(1)} часов`);
        
        // БОЛЕЕ ЛОЯЛЬНЫЕ НАСТРОЙКИ
        const maxAgeHours = {
            '1h': 2,    // 2 часа для часовых данных
            '4h': 4,    // 4 часа для 4-часовых
            '1d': 6,    // 6 часов для дневных
            '1w': 24    // 24 часа для недельных
        };
        
        const maxAge = maxAgeHours[this.timeframe] || 6;
        
        if (diffHours > maxAge) {
            console.log(`🔄 Данные устарели более чем на ${maxAge} часов`);
            return 'stale';
        } else {
            console.log('✅ Данные актуальны');
            return 'fresh';
        }
    }

    // Гарантированное обновление данных
    async guaranteedDataRefresh() {
        console.log('🔄 ГАРАНТИРОВАННОЕ ОБНОВЛЕНИЕ ДАННЫХ...');
        
        try {
            this.updateDataStatus('updating', 'Обновление данных...');
            
            const response = await fetch('/api/pattern/refresh_data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    symbol: this.symbol,
                    timeframe: this.timeframe
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                console.log('✅ ГАРАНТИРОВАННОЕ ОБНОВЛЕНИЕ УСПЕШНО:', result);
                
                // ПЕРЕЗАГРУЖАЕМ ДАННЫЕ НА ГРАФИКЕ
                await this.reloadChartData();
                
                // СБРАСЫВАЕМ ТАЙМСТАМП ДЛЯ ПРОВЕРКИ
                this.lastKnownTimestamp = null;
                if (this.chart.allCandles && this.chart.allCandles.length > 0) {
                    this.lastKnownTimestamp = this.chart.allCandles[this.chart.allCandles.length - 1].open_time;
                }
                
                // this.updateDataStatus('fresh', `Данные обновлены: ${result.fresh_data_count} записей`);
                
            } else {
                throw new Error(result.message || 'Unknown error');
            }
            
        } catch (error) {
            console.error('❌ Ошибка гарантированного обновления:', error);
            this.updateDataStatus('stale', 'Ошибка обновления');
            throw error;
        }
    }

    // Перезагрузка данных графика
    async reloadChartData() {
        console.log('🔄 ПЕРЕЗАГРУЗКА ДАННЫХ ГРАФИКА...');
        
        if (!this.chart.loadData) {
            throw new Error('Chart loadData method not available');
        }
        
        // Сохраняем текущее выделение
        const hadSelection = this.chart.selectedIndices && this.chart.selectedIndices.size > 0;
        const selectedIndices = hadSelection ? [...this.chart.selectedIndices] : [];
        
        // Перезагружаем данные
        await this.chart.loadData();
        
        // Восстанавливаем выделение
        if (hadSelection && selectedIndices.length > 0) {
            this.chart.selectedIndices.clear();
            selectedIndices.forEach(idx => {
                if (idx < this.chart.allCandles.length) {
                    this.chart.selectedIndices.add(idx);
                }
            });
            this.chart.updateSelected();
            console.log(`✅ Восстановлено выделение: ${this.chart.selectedIndices.size} свечей`);
        }
        
        console.log('✅ Данные графика перезагружены');
    }

    // Загрузка и применение обновлений
    async loadAndApplyUpdates() {
        try {
            const newData = await this.loadIncrementalData();
            
            if (newData && newData.has_updates && newData.new_candles && newData.new_candles.length > 0) {
                await this.updateChartWithNewData(newData.new_candles);
                this.lastKnownTimestamp = newData.latest_timestamp;
                
                console.log(`✅ График обновлен: ${newData.new_candles.length} новых свечей`);
            }
        } catch (error) {
            console.error('❌ Ошибка применения обновлений:', error);
        }
    }

    // Проверка обновлений
    async checkForUpdates() {
        try {
            if (!this.lastKnownTimestamp) {
                return { has_updates: false, message: 'No last known timestamp' };
            }

            const url = `/api/pattern/check_updates?symbol=${encodeURIComponent(this.symbol)}&timeframe=${this.timeframe}&last_known=${encodeURIComponent(this.lastKnownTimestamp)}`;
            console.log('🔗 URL проверки:', url);
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            return result;
            
        } catch (error) {
            console.error('❌ Ошибка проверки обновлений:', error);
            return { has_updates: false, error: error.message };
        }
    }

    // Загрузка инкрементальных данных
    async loadIncrementalData() {
        try {
            if (!this.lastKnownTimestamp) {
                return { has_updates: false, message: 'No last known timestamp' };
            }

            const url = `/api/pattern/incremental_update?symbol=${encodeURIComponent(this.symbol)}&timeframe=${this.timeframe}&last_known=${encodeURIComponent(this.lastKnownTimestamp)}`;
            console.log('🔗 URL загрузки:', url);
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            return result;
            
        } catch (error) {
            console.error('❌ Ошибка загрузки инкрементальных данных:', error);
            return { has_updates: false, error: error.message };
        }
    }

    // Обновление графика новыми данными
    async updateChartWithNewData(newCandles) {
        if (!this.chart || !this.chart.allCandles) {
            console.error('❌ График не инициализирован');
            return;
        }
        
        console.log(`🔄 Добавляем ${newCandles.length} новых свечей`);
        
        // Добавляем новые свечи к существующим данным
        let addedCount = 0;
        newCandles.forEach(newCandle => {
            const exists = this.chart.allCandles.some(candle => 
                candle.open_time === newCandle.open_time
            );
            
            if (!exists) {
                this.chart.allCandles.push(newCandle);
                addedCount++;
            }
        });
        
        console.log(`✅ Добавлено ${addedCount} новых свечей из ${newCandles.length}`);
        
        if (addedCount === 0) {
            console.log('ℹ️ Все свечи уже существуют в графике');
            return;
        }
        
        // Сортируем по дате
        this.chart.allCandles.sort((a, b) => new Date(a.open_time) - new Date(b.open_time));
        
        // Подготавливаем данные для графика
        const candleData = this.chart.allCandles.map(c => ({
            time: Math.floor(new Date(c.open_time).getTime() / 1000),
            open: parseFloat(c.open_price),
            high: parseFloat(c.high),
            low: parseFloat(c.low),
            close: parseFloat(c.close_price),
        }));
        
        const volumeData = this.chart.allCandles.map(c => ({
            time: Math.floor(new Date(c.open_time).getTime() / 1000),
            value: parseFloat(c.volume),
            color: (parseFloat(c.close_price) >= parseFloat(c.open_price)) ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'
        }));
        
        // Обновляем график
        try {
            this.chart.candleSeries.setData(candleData);
            console.log('✅ Данные свечей обновлены');
            
            if (this.chart.volumeVisible) {
                this.chart.volumeSeries.setData(volumeData);
                console.log('✅ Данные объема обновлены');
            }
            
            // Автоматически скроллим к новым данным
            if (addedCount > 0) {
                const lastCandle = this.chart.allCandles[this.chart.allCandles.length - 1];
                const lastTime = Math.floor(new Date(lastCandle.open_time).getTime() / 1000);
                
                // Увеличиваем видимый диапазон чтобы показать новые данные
                this.chart.chart.timeScale().setVisibleRange({
                    from: lastTime - 7 * 24 * 60 * 60, // 7 дней назад
                    to: lastTime + 24 * 60 * 60 // +1 день
                });
                
                console.log('🎯 График сдвинут к новым данным');
            }
            
            // Перерисовываем оверлей
            this.chart.redrawOverlay();
            
            console.log('✅ График успешно обновлен');
            
        } catch (error) {
            console.error('❌ Ошибка обновления графика:', error);
        }
    }

    // Обновление статуса данных
    updateDataStatus(status, message = '') {
        console.log(`📊 Статус данных: ${status} - ${message}`);
        
        // Обновляем элемент статуса в интерфейсе
        const statusElement = document.getElementById('update-status');
        if (statusElement) {
            if (status === 'updating') {
                statusElement.innerHTML = '<i class="fas fa-sync fa-spin"></i> Обновление...';
                statusElement.style.display = 'flex';
            } else if (status === 'fresh') {
                statusElement.innerHTML = `<i class="fas fa-check-circle"></i> ${message}`;
                statusElement.style.display = 'flex';
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);
            } else {
                statusElement.style.display = 'none';
            }
        }
        
        if (this.chart.toast) {
            this.chart.toast(message);
        }
    }

    // Остановка обновлений
    stop() {
        if (this.updateTimer) {
            console.log('⏹️ Остановка автообновлений');
            clearInterval(this.updateTimer);
            this.updateTimer = null;
        }
    }

    // Смена символа/таймфрейма
    changeSymbol(symbol, timeframe) {
        this.symbol = symbol;
        this.timeframe = timeframe;
        this.lastKnownTimestamp = null;
        this.hasPerformedInitialUpdate = false;
        this.stop();
        this.performInitialUpdate();
    }
}

class PatternChart {
    constructor() {
        this.chart = null;
        this.candleSeries = null;
        this.volumeSeries = null;
        this.volumeVisible = true;
        this.allCandles = [];
        this.selectedIndices = new Set();
        this.selectedMarkers = new Map();
        this.patternMarkers = new Map();
        
        // Восстанавливаем сохраненный таймфрейм или используем по умолчанию
        const savedTimeframe = localStorage.getItem('savedTimeframe');
        this.currentTimeframe = savedTimeframe || '1d';
        
        // Очищаем сохраненный таймфрейм после использования
        if (savedTimeframe) {
            localStorage.removeItem('savedTimeframe');
        }

        const savedSymbol = localStorage.getItem('savedSymbol');
        this.currentSymbol = savedSymbol || 'BTC#USDT';
        
        // Очищаем сохраненный символ после использования
        if (savedSymbol) {
            localStorage.removeItem('savedSymbol');
        }
        
        this.dataInitiallyLoaded = false;
        this.chartUpdater = new SmartChartUpdater(this);
        
        this.initChart();
        this.loadData();
        this.bindUI();
        this.toastEl = null;
        this.overlay = null;
        this.matchedHighlightPoints = [];
        this.selectedHighlightPoints = [];
        this.currentMatchIndex = -1;
        this.matchedRanges = [];
        this.isAnalysisMode = false;
    }

    // Инициализация графика
    initChart() {
        const el = document.getElementById('chart');
        this.chart = LightweightCharts.createChart(el, {
            width: el.clientWidth,
            height: el.clientHeight,
            layout: { backgroundColor: '#0a0f14', textColor: '#d6dee6', fontFamily: 'Inter' },
            grid: { vertLines: { color: 'rgba(32,42,54,0.85)' }, horzLines: { color: 'rgba(32,42,54,0.85)' } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Magnet, vertLine: { color: '#3a4654' }, horzLine: { color: '#3a4654' } },
            rightPriceScale: { borderColor: '#243142' },
            timeScale: { 
                borderColor: '#243142', 
                rightOffset: 6, 
                barSpacing: 14,
                minBarSpacing: 3,
                fixLeftEdge: false,
                fixRightEdge: false,
                lockVisibleTimeRangeOnResize: true,
                shiftVisibleRangeOnNewBar: true,
                timeVisible: true,
                secondsVisible: false
            },
            handleScroll: { 
                mouseWheel: true, 
                pressedMouseMove: true,
                horzTouchDrag: true,
                vertTouchDrag: true
            },
            handleScale: { 
                axisPressedMouseMove: { time: true, price: true },
                axisDoubleClickReset: { time: true, price: true },
                mouseWheel: true,
                pinch: true
            },
            kineticScroll: {
                touch: true,
                mouse: true
            }
        });
        
        this.candleSeries = this.chart.addCandlestickSeries({
            upColor: '#21d07a',
            downColor: '#f04444',
            borderUpColor: '#1ac46f',
            borderDownColor: '#e73c3c',
            wickUpColor: '#24e084',
            wickDownColor: '#ff5050',
            priceLineVisible: false,
        });
        
        // Улучшенный зум мышью: зум к курсору, более чувствительный, с панорамированием по Shift+колесику
        (function enhanceWheelZoom(chart, el) {
            const baseZoom = 1.08; // мягче
            let lastTs = 0;
            el.addEventListener('wheel', (evt) => {
                const now = Date.now();
                if (now - lastTs < 16) return; // ~60fps
                lastTs = now;
                const ts = chart.timeScale();
                if (!ts) return;

                // Блокируем прокрутку страницы, работаем сами
                evt.preventDefault();

                const range = ts.getVisibleRange && ts.getVisibleRange();
                if (!range || typeof range.from !== 'number' || typeof range.to !== 'number') return;

                const total = range.to - range.from;

                // 1) Горизонтальная прокрутка: Shift+колесо ИЛИ колесо-влево/вправо (deltaX)
                const isPanX = evt.shiftKey || (Math.abs(evt.deltaX) > Math.abs(evt.deltaY));
                if (isPanX) {
                    const raw = Math.abs(evt.deltaX) > Math.abs(evt.deltaY) ? evt.deltaX : evt.deltaY;
                    const direction = Math.sign(raw) || 1; // + вправо, - влево
                    const step = Math.min(2.5, Math.max(0.5, Math.abs(raw) / 180));
                    const shift = total * 0.06 * step * direction;
                    ts.setVisibleRange({ from: range.from + shift, to: range.to + shift });
                    return;
                }

                // Зум к позиции курсора
                const cursorX = (typeof evt.offsetX === 'number') ? evt.offsetX : 0;
                let focusTime = undefined;
                if (typeof ts.coordinateToTime === 'function') {
                    focusTime = ts.coordinateToTime(cursorX);
                }
                if (typeof focusTime !== 'number') {
                    // если не удалось получить точку фокуса — зум просто вокруг центра
                    focusTime = (range.from + range.to) / 2;
                }

                // Вычисляем коэффициент зума с учётом скорости прокрутки и Ctrl/⌘ для ускорения
                const magnitude = Math.min(2.0, Math.max(0.5, Math.abs(evt.deltaY) / 240));
                const turbo = (evt.ctrlKey || evt.metaKey) ? 1.2 : 1.0;
                const zoomFactor = Math.pow(baseZoom * turbo, magnitude);
                const zoomIn = evt.deltaY < 0; // колёсико вверх — приближение

                const left = Math.max(1e-6, focusTime - range.from);
                const right = Math.max(1e-6, range.to - focusTime);

                let newLeft, newRight;
                if (zoomIn) {
                    newLeft = left / zoomFactor;
                    newRight = right / zoomFactor;
                } else {
                    newLeft = left * zoomFactor;
                    newRight = right * zoomFactor;
                }

                // Ограничим минимальную ширину диапазона, чтобы не «залипать»
                const minSpan = Math.max(2, total * 0.0005);
                const newFrom = focusTime - newLeft;
                const newTo = focusTime + newRight;
                if ((newTo - newFrom) < minSpan) return;

                ts.setVisibleRange({ from: newFrom, to: newTo });
            }, { passive: false });
        })(this.chart, el);
        
        this.volumeSeries = this.chart.addHistogramSeries({
            priceScaleId: '',
            scaleMargins: { top: 0.85, bottom: 0 },
            priceFormat: { type: 'volume' },
        });

        this.chart.subscribeClick(this.onClick.bind(this));
        window.addEventListener('resize', () => { 
            this.chart.applyOptions({ width: el.clientWidth }); 
            this.resizeOverlay(); 
            this.redrawOverlay(); 
        });
        
        this.ensureOverlay();
        
        // Подписываемся на изменения видимого диапазона
        this.chart.timeScale().subscribeVisibleTimeRangeChange(() => {
            setTimeout(() => this.redrawOverlay(), 10);
        });
        
        // Добавляем анимацию для пульсирующего эффекта
        this.animationFrame = null;
        this.startAnimation();
    }

    // Загрузка данных
// Загрузка данных
    async loadData() {
        try {
            console.log(`📥 Загрузка данных для ${this.currentSymbol}, ТФ: ${this.currentTimeframe}`);
            
            // Устанавливаем фиксированные даты с 2017 года
            const dsStart = new Date('2017-01-01T00:00:00Z');
            const dsEnd = new Date();
            
            // Добавляем 1 день к конечной дате для включения текущего дня
            const nextDay = new Date(dsEnd);
            nextDay.setDate(dsEnd.getDate() + 1);
            
            console.log(`📅 Диапазон данных: ${dsStart.toISOString().slice(0,10)} - ${nextDay.toISOString().slice(0,10)}`);
            
            // ОЧИСТКА ПРЕДЫДУЩИХ ДАННЫХ
            this.allCandles = [];
            this.candleSeries.setData([]);
            this.volumeSeries.setData([]);
            
            // Загружаем реальные свечи с сервера
            const api = await fetch(
                `/api/pattern/ohlcv?source=binance` +
                `&from=${dsStart.toISOString().slice(0,10)}` +
                `&to=${nextDay.toISOString().slice(0,10)}` +
                `&timeframe=${this.currentTimeframe}` +
                `&symbol=${this.currentSymbol}`
            );
            
            if (!api.ok) {
                throw new Error(`HTTP ${api.status}: Не удалось загрузить OHLCV`);
            }
            
            const aj = await api.json();
            if (!aj.success) {
                throw new Error(aj.message || 'Ошибка загрузки OHLCV');
            }
            
            this.allCandles = aj.candles || [];

            if (!Array.isArray(this.allCandles) || this.allCandles.length === 0) {
                throw new Error('Пустой набор свечей');
            }
            
            console.log(`✅ Загружено ${this.allCandles.length} свечей`);
            
            // Нормализация типов
            this.allCandles = this.allCandles.map(c => ({
                open_time: c.open_time,
                close_time: c.close_time,
                open_price: Number(c.open_price),
                close_price: Number(c.close_price),
                high: Number(c.high),
                low: Number(c.low),
                volume: Number(c.volume),
            }));
            
            // Подготавливаем данные для графика
            const k = this.allCandles.map(c => ({
                time: Math.floor(new Date(c.open_time).getTime() / 1000),
                open: c.open_price, 
                high: c.high, 
                low: c.low, 
                close: c.close_price,
            }));
            
            this.candleSeries.setData(k);

            const v = this.allCandles.map(c => ({
                time: Math.floor(new Date(c.open_time).getTime() / 1000),
                value: c.volume,
                color: (c.close_price >= c.open_price) ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'
            }));
            
            this.volumeSeries.setData(v);
            
            // Устанавливаем границы датасета
            this.datasetStart = new Date(this.allCandles[0].open_time);
            this.datasetEnd = new Date(this.allCandles[this.allCandles.length - 1].open_time);
            
            console.log(`📊 Диапазон данных: ${this.datasetStart.toLocaleDateString()} - ${this.datasetEnd.toLocaleDateString()}`);
            
            // Подгоняем отображение под данные
            this.chart.timeScale().fitContent();
            
            setTimeout(() => { 
                try { 
                    this.chart.timeScale().fitContent(); 
                } catch(e) {
                    console.warn('Ошибка при подгонке графика:', e);
                } 
            }, 0);
            
            // Увеличиваем масштаб для лучшего отображения свечей
            setTimeout(() => {
                try {
                    const range = this.chart.timeScale().getVisibleRange();
                    if (range) {
                        const totalRange = range.to - range.from;
                        const visibleRange = totalRange * 0.5; // Показываем 50% данных (более отдалённо)
                        this.chart.timeScale().setVisibleRange({
                            from: range.to - visibleRange,
                            to: range.to
                        });
                    }
                    this.redrawOverlay();
                } catch(e) {
                    console.warn('Ошибка при настройке видимого диапазона:', e);
                }
            }, 100);
            
            // После загрузки данных запускаем систему обновлений
            if (this.allCandles.length > 0) {
                console.log('🚀 Данные загружены, запускаем систему обновлений');
                
                // ПЕРВАЯ ПРОВЕРКА СВЕЖЕСТИ ПРИ ЗАГРУЗКЕ
                if (!this.dataInitiallyLoaded) {
                    this.dataInitiallyLoaded = true;
                    await this.initialFreshnessCheck();
                }
                
                // ЗАПУСК АВТООБНОВЛЕНИЯ
                this.chartUpdater.initialize(this.currentSymbol, this.currentTimeframe);
            }
            
        } catch (e) {
            console.error('Ошибка загрузки данных:', e);
            this.toast('Не удалось загрузить исторические данные: ' + e.message);
        }
    }
    // Первичная проверка свежести данных
    async initialFreshnessCheck() {
        console.log('🔍 ПЕРВИЧНАЯ ПРОВЕРКА СВЕЖЕСТИ ДАННЫХ...');
        
        const freshness = this.chartUpdater.checkDataFreshness();
        
        if (freshness === 'stale') {
            console.log('🔄 Данные устарели при загрузке, запускаем немедленное обновление...');
            
            // НЕМЕДЛЕННОЕ ОБНОВЛЕНИЕ ПРИ ЗАГРУЗКЕ УСТАРЕВШИХ ДАННЫХ
            try {
                await this.chartUpdater.guaranteedDataRefresh();
                console.log('✅ Данные обновлены при загрузке');
            } catch (error) {
                console.error('❌ Не удалось обновить данные при загрузке:', error);
            }
        }
    }

    // Привязка UI событий
    bindUI() {
        // Обработчики кнопок
        const analyzeBtn = document.getElementById('analyze-btn'); 
        if (analyzeBtn) analyzeBtn.addEventListener('click', () => this.analyze());
        
        const clearBtn = document.getElementById('clear-btn'); 
        if (clearBtn) clearBtn.addEventListener('click', () => this.showClearConfirmationModal());
        
        const toggleVolumeBtn = document.getElementById('toggle-volume-btn'); 
        if (toggleVolumeBtn) toggleVolumeBtn.addEventListener('click', () => this.toggleVolume());
        
        // Обработчики таймфреймов
        document.querySelectorAll('[data-tf]').forEach(b => b.addEventListener('click', (e) => {
            document.querySelectorAll('[data-tf]').forEach(x => x.classList.remove('active'));
            e.target.classList.add('active');
            const newTF = e.target.getAttribute('data-tf');
            if (newTF !== this.currentTimeframe) {
                this.switchTimeframe(newTF);
            }
        }));

        // Обработчики мобильной навигации
        const navVolume = document.getElementById('nav-volume'); 
        if (navVolume) navVolume.addEventListener('click', () => this.toggleVolume());
        
        const navAnalysis = document.getElementById('nav-analysis'); 
        if (navAnalysis) navAnalysis.addEventListener('click', () => this.analyze());
        
        const navClear = document.getElementById('nav-clear'); 
        if (navClear) navClear.addEventListener('click', () => this.showClearConfirmationModal());
        
        // Обработчики элементов управления графиком
        const navPrev = document.getElementById('nav-prev'); 
        if (navPrev) navPrev.addEventListener('click', () => this.gotoMatch(-1));
        
        const navNext = document.getElementById('nav-next'); 
        if (navNext) navNext.addEventListener('click', () => this.gotoMatch(1));
        
        const navToSelected = document.getElementById('nav-to-selected'); 
        if (navToSelected) navToSelected.addEventListener('click', () => this.zoomToSelected());
        
        const navAnalysisOverlay = document.getElementById('nav-analysis-overlay'); 
        if (navAnalysisOverlay) navAnalysisOverlay.addEventListener('click', () => this.toggleAnalysisPanel());
        
        const navPatterns = document.getElementById('nav-patterns'); 
        if (navPatterns) navPatterns.addEventListener('click', () => this.showPatternsModal());
        
        const toggleControlsBtn = document.getElementById('toggle-controls-btn'); 
        if (toggleControlsBtn) toggleControlsBtn.addEventListener('click', () => this.toggleChartControls());
        
        // Обработчик выбора символа
        const symbolSelect = document.getElementById('symbol-select');
        if (symbolSelect) {
            symbolSelect.value = this.currentSymbol;
            symbolSelect.addEventListener('change', (e) => {
                this.switchSymbol(e.target.value);
            });
        }

        // Обработчики модальных окон
        document.getElementById('confirm-clear-btn').addEventListener('click', () => {
            localStorage.setItem('savedTimeframe', this.currentTimeframe);
            localStorage.setItem('savedSymbol', this.currentSymbol);
            window.location.reload();
        });
        
        document.getElementById('cancel-clear-btn').addEventListener('click', () => this.hideClearConfirmationModal());
        document.getElementById('close-clear-modal').addEventListener('click', () => this.hideClearConfirmationModal());
        document.querySelector('.close-modal').addEventListener('click', () => this.hidePatternsModal());
        
        // Закрытие модальных окон по клику вне области
        document.getElementById('patterns-modal').addEventListener('click', (e) => {
            if (e.target.id === 'patterns-modal') {
                this.hidePatternsModal();
            }
        });
        
        document.getElementById('clear-confirmation-modal').addEventListener('click', (e) => {
            if (e.target.id === 'clear-confirmation-modal') {
                this.hideClearConfirmationModal();
            }
        });
        
        // Кнопка ручного обновления
        const manualRefreshBtn = document.getElementById('manual-refresh-btn');
        if (manualRefreshBtn) {
            manualRefreshBtn.addEventListener('click', () => this.manualRefreshData());
        }
        
        // Устанавливаем активный таймфрейм в UI
        this.setActiveTimeframe();
    }

    // Обработчик клика на графике
    onClick(param) {
        if (!param || !param.time) return;
        const ts = param.time;
        const idx = this.allCandles.findIndex(c => Math.floor(new Date(c.open_time).getTime()/1000) === ts);
        if (idx === -1) return;
        
        // Блокируем выбор свечей вне границ датасета
        const t = new Date(this.allCandles[idx].open_time);
        if (this.datasetStart && this.datasetEnd && (t < this.datasetStart || t > this.datasetEnd)) {
            this.toast('Свеча вне диапазона датасета');
            return;
        }
        
        if (this.selectedIndices.has(idx)) {
            this.selectedIndices.delete(idx);
        } else {
            if (this.selectedIndices.size >= 6) { 
                this.toast('Можно выбрать максимум 6 свечей'); 
                return; 
            }
            this.selectedIndices.add(idx);
        }
        this.updateSelected();
    }

    // Обновление выбранных свечей
    updateSelected() {
        safeSetTextContent('selected-count', this.selectedIndices.size);
        const analyzeBtn = document.getElementById('analyze-btn'); 
        if (analyzeBtn) analyzeBtn.disabled = this.selectedIndices.size === 0;
        
        this.selectedMarkers.clear();
        this.selectedHighlightPoints = [];
        [...this.selectedIndices].forEach((i, index) => {
            const t = Math.floor(new Date(this.allCandles[i].open_time).getTime()/1000);
            this.selectedMarkers.set(i, { 
                time: t, 
                position: 'aboveBar', 
                color: '#3b82f6', 
                shape: 'circle', 
                text: `${index + 1}`, 
                size: 1.5,
                textColor: '#ffffff',
                backgroundColor: '#3b82f6'
            });
            this.selectedHighlightPoints.push({ time: t, color: '#3b82f6', index: index + 1 });
        });
        this.applyMarkers();
        this.redrawOverlay();
    }

    // Применение маркеров
    applyMarkers() {
        const sel = Array.from(this.selectedMarkers.values());
        const pats = Array.from(this.patternMarkers.values()).flat();
        this.candleSeries.setMarkers([...sel, ...pats]);
    }

    // Очистка выбора
    clearSelection() {
        this.selectedIndices.clear();
        this.selectedMarkers.clear();
        this.selectedHighlightPoints = [];
        this.applyMarkers();
        safeSetTextContent('selected-count', '0');
        const analyzeBtn = document.getElementById('analyze-btn');
        if (analyzeBtn) analyzeBtn.disabled = true;
        this.redrawOverlay();
    }

    // Переключение объема
    toggleVolume() {
        this.volumeVisible = !this.volumeVisible;
        if (this.volumeVisible) {
            const v = this.allCandles.map(c => ({
                time: Math.floor(new Date(c.open_time).getTime() / 1000),
                value: +c.volume,
                color: (+c.close_price >= +c.open_price) ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'
            }));
            this.volumeSeries.setData(v);
        } else {
            this.volumeSeries.setData([]);
        }
        
        // Обновляем текст кнопок
        const buttonText = this.volumeVisible ? 'Скрыть объем' : 'Показать объем';
        const iconClass = this.volumeVisible ? 'fas fa-chart-bar' : 'fas fa-chart-bar';
        
        // Обновляем кнопку в toolbar
        const toggleVolumeBtn = document.getElementById('toggle-volume-btn');
        if (toggleVolumeBtn) {
            toggleVolumeBtn.title = buttonText;
            toggleVolumeBtn.innerHTML = `<i class="${iconClass}"></i> ${this.volumeVisible ? 'Объем' : 'Объем'}`;
        }
        
        // Обновляем кнопку в мобильной навигации
        const navVolume = document.getElementById('nav-volume');
        if (navVolume) {
            navVolume.innerHTML = `<i class="${iconClass}"></i><span>${this.volumeVisible ? 'Объем' : 'Объем'}</span>`;
        }
        
        this.toast(this.volumeVisible ? 'Объем показан' : 'Объем скрыт');
    }

    // Анализ паттерна
    async analyze() {
        if (this.selectedIndices.size === 0) return;
        const order = [...this.selectedIndices].sort((a,b) => a-b);
        const candles = order.map(i => this.allCandles[i]);
        
        const payload = { 
            num_candles: this.selectedIndices.size,
            candles, 
            timeframe: this.currentTimeframe,
            symbol: this.currentSymbol,
            no_cache: true
        };
        
        // UI state
        const btn = document.getElementById('analyze-btn');
        const loader = this.ensureLoader();
        if (btn) btn.disabled = true; 
        loader.style.display = 'flex';
        
        try {
            console.log('Отправляем запрос на анализ паттерна...');
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 120000);
            
            const res = await fetch('/api/pattern/analyze', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify(payload),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            console.log('Получен ответ:', res.status);
            
            if (!res.ok) {
                if (res.status === 408) {
                    throw new Error('Превышено время ожидания. Попробуйте выбрать меньший период или повторите попытку.');
                } else if (res.status === 500) {
                    throw new Error('Ошибка сервера. Попробуйте позже.');
                } else {
                    throw new Error(`Ошибка сервера: ${res.status}`);
                }
            }
            
            const data = await res.json();
            console.log('Данные анализа:', data);
            
            if (!data.success) {
                throw new Error(data.message || 'Ошибка анализа');
            }
            
            this.renderResults(data);
            this.drawPatternMarkers(data.matched_patterns);
            if (!data.matched_patterns || data.matched_patterns.length === 0) this.toast('Совпадения не найдены');
            this.toast('Анализ завершён');
            
            // Show chart controls after analysis
            const chartControls = document.getElementById('chart-controls');
            if (chartControls) chartControls.classList.add('visible');
            this.switchToAnalysisMode();

        } catch (e) {
            if (e.name === 'AbortError') {
                this.toast('Превышено время ожидания. Попробуйте выбрать меньший период.');
            } else {
                this.toast('Ошибка: ' + e.message);
            }
            console.error('Ошибка анализа:', e);
        } finally {
            if (btn) btn.disabled = this.selectedIndices.size === 0;
            loader.style.display = 'none';
        }
    }

    // Отрисовка результатов анализа
    renderResults(result) {
        console.log("🎯 Начинаем отрисовку результатов...", result);
        
        safeSetTextContent('matches-found', result.statistics.matches_found);
        safeSetTextContent('pattern-length', result.pattern_info.pattern_len);
        
        const percents = result.statistics.distribution_percents || {};
        const avg = Object.keys(percents).length ? (Object.values(percents).reduce((a,b)=>a+b,0) / Object.keys(percents).length) : 0;
        safeSetTextContent('accuracy', (avg||0).toFixed(2) + '%');

        const patternInfoHTML = `
            <div class="stat"><span>Начало</span><span class="val">${new Date(result.pattern_info.pattern_start).toLocaleDateString()}</span></div>
            <div class="stat"><span>Конец</span><span class="val">${new Date(result.pattern_info.pattern_end).toLocaleDateString()}</span></div>
            <div class="stat"><span>Свечей</span><span class="val">${result.pattern_info.pattern_len}</span></div>
            <div class="stat"><span>Таймфрейм</span><span class="val">${result.pattern_info.timeframe}</span></div>
        `;
        safeSetInnerHTML('pattern-info', patternInfoHTML);
        safeSetStyle('pattern-info-card', 'display', '');

        // Очищаем предыдущие совпадения
        safeSetInnerHTML('matches', '');
        this.matchedRanges = [];
        
        // Отрисовываем список совпадений
        (result.matched_patterns || []).forEach((pat, i) => {
            const first = pat[0];
            const last = pat[pat.length-1];
            const change = result.price_changes ? result.price_changes[i] : 0;
            
            this.matchedRanges.push([ 
                Math.floor(new Date(first.date).getTime()/1000), 
                Math.floor(new Date(last.date).getTime()/1000) 
            ]);
            
            const el = document.createElement('div');
            el.className = 'match';
            el.setAttribute('data-pattern-index', i);
            el.innerHTML = `
                <div class="hdr">
                    <div class="range">
                        <span style="color: var(--accent); font-weight: 600;">Паттерн ${i + 1}</span>
                        <br>
                        <small style="color: var(--muted);">${new Date(first.date).toLocaleDateString()} — ${new Date(last.date).toLocaleDateString()}</small>
                    </div>
                    <div class="badge ${change>=0?'up':'down'}">${change>=0?'+':''}${change.toFixed(2)}%</div>
                </div>
            `;
            el.addEventListener('click', () => {
                document.querySelectorAll('.match').forEach(m => m.classList.remove('active'));
                el.classList.add('active');
                
                this.currentMatchIndex = i;
                this.updateMatchIndexLabel();
                const [from, to] = this.matchedRanges[i];
                this.zoomTo(from, to);
            });
            document.getElementById('matches').appendChild(el);
        });
        
        this.currentMatchIndex = this.matchedRanges.length ? 0 : -1;
        this.updateMatchIndexLabel();

        // ВАЖНО: Отрисовываем общую аналитику ПОСЛЕДНЕЙ
        setTimeout(() => {
            this.renderGeneralAnalysis(result);
        }, 100);
        
        console.log("✅ Результаты отрисованы");
    }

    // Отрисовка общей аналитики паттернов
    // Отрисовка общей аналитики паттернов
    renderGeneralAnalysis(result) {
        console.log("📊 Начинаем отрисовку общей аналитики...", result);
        
        const performanceStats = result.performance_stats;
        if (!performanceStats) {
            console.error('❌ Performance stats not found in result:', result);
            this.showGeneralAnalysisError('Данные аналитики не найдены');
            return;
        }

        console.log("📈 Performance stats:", performanceStats);

        // Создаем или находим карточку общей аналитики
        let analysisCard = document.getElementById('general-analysis-card');
        if (!analysisCard) {
            analysisCard = document.createElement('div');
            analysisCard.className = 'card';
            analysisCard.id = 'general-analysis-card';
            
            // Вставляем карточку в начало side-panel
            const sidePanel = document.getElementById('side-panel');
            if (sidePanel) {
                // Вставляем перед первой карточкой или в начало
                const firstCard = sidePanel.querySelector('.card');
                if (firstCard) {
                    sidePanel.insertBefore(analysisCard, firstCard);
                } else {
                    sidePanel.prepend(analysisCard);
                }
                console.log("✅ Карточка аналитики создана и вставлена");
            } else {
                console.error('❌ Side panel not found');
                return;
            }
        }

        // Заполняем карточку с новыми данными
        analysisCard.innerHTML = `
            <h3><i class="fas fa-chart-pie"></i> Общая аналитика паттернов</h3>
            <div class="performance-summary">
                <div class="summary-item">
                    <span class="summary-label">Медианное изменение:</span>
                    <span class="summary-value ${performanceStats.median_change >= 0 ? 'bullish' : 'bearish'}">
                        ${performanceStats.median_change >= 0 ? '+' : ''}${performanceStats.median_change || 0}%
                    </span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Успешность:</span>
                    <span class="summary-value bullish">${performanceStats.success_rate || 0}%</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Медиана растущих:</span>
                    <span class="summary-value bullish">+${performanceStats.median_bullish || 0}%</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Медиана падающих:</span>
                    <span class="summary-value bearish">${performanceStats.median_bearish || 0}%</span>
                </div>
                <div class="summary-item">
                    <span class="summary-label">Всего паттернов:</span>
                    <span class="summary-value">${performanceStats.total_patterns || 0}</span>
                </div>
            </div>
            
            <div class="pattern-distribution">
                <h4 style="margin: 15px 0 8px 0; font-size: 12px; color: var(--muted);">Распределение направлений</h4>
                <div class="distribution-item">
                    <span class="distribution-label">Бычьи</span>
                    <div class="distribution-bar">
                        <div class="distribution-fill bullish" style="width: ${performanceStats.bullish_percentage || 0}%"></div>
                    </div>
                    <span class="distribution-value">${performanceStats.bullish_percentage || 0}%</span>
                </div>
                <div class="distribution-item">
                    <span class="distribution-label">Медвежьи</span>
                    <div class="distribution-bar">
                        <div class="distribution-fill bearish" style="width: ${performanceStats.bearish_percentage || 0}%"></div>
                    </div>
                    <span class="distribution-value">${performanceStats.bearish_percentage || 0}%</span>
                </div>
            </div>
            
            <div class="footer-note" style="margin-top: 12px; border-top: 1px solid var(--border); padding-top: 8px;">
                <small>Анализ основан на ${performanceStats.valid_patterns || 0} исторических совпадениях</small>
            </div>
        `;

        console.log("✅ Общая аналитика отрисована");
    }
    // Метод для показа ошибки
    showGeneralAnalysisError(message) {
        let analysisCard = document.getElementById('general-analysis-card');
        if (!analysisCard) {
            analysisCard = document.createElement('div');
            analysisCard.className = 'card';
            analysisCard.id = 'general-analysis-card';
            
            const sidePanel = document.getElementById('side-panel');
            if (sidePanel) {
                const firstCard = sidePanel.querySelector('.card');
                if (firstCard) {
                    sidePanel.insertBefore(analysisCard, firstCard);
                } else {
                    sidePanel.prepend(analysisCard);
                }
            }
        }
        
        analysisCard.innerHTML = `
            <h3><i class="fas fa-chart-pie"></i> Общая аналитика паттернов</h3>
            <div style="text-align: center; padding: 20px; color: var(--muted);">
                <i class="fas fa-exclamation-triangle" style="font-size: 24px; margin-bottom: 10px;"></i>
                <p>${message}</p>
            </div>
        `;
    }

    // Отрисовка маркеров паттернов
    drawPatternMarkers(matched) {
        // Убираем маркеры-квадраты и номера: оставляем только линии на оверлее
        this.patternMarkers.clear();
        this.matchedHighlightPoints = [];
        (matched || []).forEach((pat, pIdx) => {
            for (let i=0;i<pat.length;i++) {
                const t = Math.floor(new Date(pat[i].date).getTime()/1000);
                this.matchedHighlightPoints.push({ time: t });
            }
        });
        // Не добавляем паттерн-маркеры в setMarkers — только перерисовываем оверлей
        this.redrawOverlay();
        if (matched && matched.length && matched[0].length) {
            const f = matched[0][0];
            const l = matched[0][matched[0].length-1];
            this.zoomTo(Math.floor(new Date(f.date).getTime()/1000), Math.floor(new Date(l.date).getTime()/1000));
        }
    }

    // Масштабирование к области
    zoomTo(from, to) {
        const pad = Math.max(3*24*60*60, Math.floor((to-from)*0.5));
        this.chart.timeScale().setVisibleRange({ from: from - pad, to: to + pad });
        
        setTimeout(() => {
            this.redrawOverlay();
        }, 50);
    }

    // ===== Overlay helpers for highlighting candles =====
    ensureOverlay() {
        if (this.overlay) return this.overlay;
        const host = document.getElementById('chart');
        const canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.pointerEvents = 'none';
        canvas.style.zIndex = '5';
        canvas.width = host.clientWidth; canvas.height = host.clientHeight;
        host.appendChild(canvas);
        this.overlay = canvas;
        return canvas;
    }

    resizeOverlay() {
        const host = document.getElementById('chart');
        if (!this.overlay) return;
        this.overlay.width = host.clientWidth;
        this.overlay.height = host.clientHeight;
    }

    redrawOverlay() {
        this.ensureOverlay();
        if (!this.overlay) return;
        
        const ctx = this.overlay.getContext('2d');
        ctx.clearRect(0,0,this.overlay.width,this.overlay.height);
        
        const ts = this.chart.timeScale();
        const barW = ts.getBarSpacing ? ts.getBarSpacing() : 12;
        const h = this.overlay.height;
        
        // Рисуем найденные паттерны синими вертикальными линиями (менее заметно)
        for (const p of (this.matchedHighlightPoints || [])) {
            const x = ts.timeToCoordinate(p.time);
            if (x === null || x === undefined) continue;
            ctx.save();
            ctx.strokeStyle = 'rgba(59,130,246,0.42)';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(Math.round(x) + 0.5, 0);
            ctx.lineTo(Math.round(x) + 0.5, h);
            ctx.stroke();
            ctx.restore();
        }
        // Больше не выделяем выбранные вручную свечи полосами
    }

    hexToRgba(hex, a) {
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!m) return `rgba(255,255,255,${a})`;
        const r = parseInt(m[1], 16), g = parseInt(m[2], 16), b = parseInt(m[3], 16);
        return `rgba(${r},${g},${b},${a})`;
    }

    startAnimation() {
        const animate = () => {
            this.redrawOverlay();
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    }

    stopAnimation() {
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
    }

    ensureLoader() {
        let el = document.querySelector('.loading');
        if (!el) {
            el = document.createElement('div'); el.className = 'loading';
            const sp = document.createElement('div'); sp.className = 'spinner'; el.appendChild(sp);
            document.body.appendChild(el);
        }
        return el;
    }

    toast(msg) {
        if (!this.toastEl) { this.toastEl = document.createElement('div'); this.toastEl.className = 'toast'; document.body.appendChild(this.toastEl); }
        this.toastEl.textContent = msg; this.toastEl.style.display = 'block';
        clearTimeout(this.toastTimer); this.toastTimer = setTimeout(() => { this.toastEl.style.display = 'none'; }, 2200);
    }

    // ===== Navigation helpers =====
    zoomToSelected() {
        if (!this.selectedIndices.size) { this.toast('Сначала выберите свечи'); return; }
        
        this.updateSelected();
        this.applyMarkers();
        this.redrawOverlay();
        
        const sorted = [...this.selectedIndices].sort((a,b)=>a-b);
        const first = Math.floor(new Date(this.allCandles[sorted[0]].open_time).getTime()/1000);
        const last = Math.floor(new Date(this.allCandles[sorted[sorted.length-1]].open_time).getTime()/1000);
        
        this.zoomTo(first, last);
        
        setTimeout(() => {
            this.updateSelected();
            this.applyMarkers();
            this.redrawOverlay();
        }, 100);
        
        setTimeout(() => {
            this.updateSelected();
            this.applyMarkers();
            this.redrawOverlay();
        }, 300);
    }

    gotoMatch(step) {
        if (!this.matchedRanges.length) { this.toast('Совпадений нет'); return; }
        if (this.currentMatchIndex === -1) this.currentMatchIndex = 0;
        else this.currentMatchIndex = (this.currentMatchIndex + step + this.matchedRanges.length) % this.matchedRanges.length;
        this.updateMatchIndexLabel();
        
        document.querySelectorAll('.match').forEach(m => m.classList.remove('active'));
        const activeMatch = document.querySelector(`[data-pattern-index="${this.currentMatchIndex}"]`);
        if (activeMatch) activeMatch.classList.add('active');
        
        const [from, to] = this.matchedRanges[this.currentMatchIndex];
        this.zoomTo(from, to);
        
        setTimeout(() => {
            this.redrawOverlay();
            this.applyMarkers();
        }, 100);
    }

    updateMatchIndexLabel() {
        const label = this.matchedRanges.length ? `${this.currentMatchIndex+1}/${this.matchedRanges.length}` : '0/0';
        safeSetTextContent('match-index', label);
    }

    showPatternsModal() {
        const modal = document.getElementById('patterns-modal');
        const patternsList = document.getElementById('modal-patterns-list');
        const patternStats = document.getElementById('modal-pattern-stats');
        
        patternsList.innerHTML = '';
        patternStats.innerHTML = '';
        
        if (this.matchedRanges && this.matchedRanges.length > 0) {
            const selectedCount = this.selectedIndices.size;
            const patternLength = selectedCount;
            const matchesFound = this.matchedRanges.length;
            
            patternStats.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;">
                    <div class="stat">
                        <span style="color: var(--muted); font-size: 12px;">Выбрано свечей</span>
                        <span class="val" style="color: var(--accent); font-weight: 600;">${selectedCount}</span>
                    </div>
                    <div class="stat">
                        <span style="color: var(--muted); font-size: 12px;">Найдено совпадений</span>
                        <span class="val" style="color: var(--green); font-weight: 600;">${matchesFound}</span>
                    </div>
                </div>
                <div style="font-size: 11px; color: var(--muted); text-align: center;">
                    Кликните на паттерн для перехода к нему на графике
                </div>
            `;
            
            this.matchedRanges.forEach((range, index) => {
                const startDate = new Date(range[0] * 1000).toLocaleDateString();
                const endDate = new Date(range[1] * 1000).toLocaleDateString();
                
                const patternEl = document.createElement('div');
                patternEl.className = 'match';
                patternEl.innerHTML = `
                    <div class="hdr">
                        <div class="range">Паттерн ${index + 1}</div>
                        <div class="badge up">${index + 1}</div>
                    </div>
                    <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
                        ${startDate} — ${endDate}
                    </div>
                `;
                patternEl.addEventListener('click', () => {
                    this.currentMatchIndex = index;
                    this.updateMatchIndexLabel();
                    this.zoomTo(range[0], range[1]);
                    this.hidePatternsModal();
                });
                patternsList.appendChild(patternEl);
            });
        } else {
            patternStats.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">Сначала выберите свечи и запустите анализ</div>';
            patternsList.innerHTML = '';
        }
        
        modal.style.display = 'block';
    }

    hidePatternsModal() {
        const modal = document.getElementById('patterns-modal');
        modal.style.display = 'none';
    }

    showClearConfirmationModal() {
        localStorage.setItem('savedSymbol', this.currentSymbol);
        const modal = document.getElementById('clear-confirmation-modal');
        safeSetTextContent('selected-count-modal', this.selectedIndices.size);
        safeSetTextContent('patterns-count-modal', this.matchedRanges.length);
        if (modal) modal.style.display = 'block';
    }

    hideClearConfirmationModal() {
        const modal = document.getElementById('clear-confirmation-modal');
        modal.style.display = 'none';
    }

    toggleChartControls() {
        const chartControls = document.getElementById('chart-controls');
        const toggleBtn = document.getElementById('toggle-controls-btn');
        const toggleIcon = toggleBtn.querySelector('i');
        
        if (chartControls.classList.contains('collapsed')) {
            chartControls.classList.remove('collapsed');
            toggleIcon.className = 'fas fa-chevron-down';
        } else {
            chartControls.classList.add('collapsed');
            toggleIcon.className = 'fas fa-chevron-up';
        }
    }

    toggleAnalysisPanel() {
        if (window.innerWidth <= 768) {
            this.showAnalysisModal();
        } else {
            const sidePanel = document.getElementById('side-panel');
            if (sidePanel) {
                const isVisible = sidePanel.classList.contains('active');
                if (isVisible) {
                    sidePanel.classList.remove('active');
                    this.toast('Анализ скрыт');
                } else {
                    sidePanel.classList.add('active');
                    this.toast('Анализ показан');
                }
            }
        }
    }

    showAnalysisModal() {
        let modal = document.getElementById('analysis-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'analysis-modal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">Подробный анализ</div>
                        <button class="close-modal">&times;</button>
                    </div>
                    <div class="modal-body" id="analysis-modal-body">
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            modal.querySelector('.close-modal').addEventListener('click', () => this.hideAnalysisModal());
            modal.addEventListener('click', (e) => {
                if (e.target.id === 'analysis-modal') {
                    this.hideAnalysisModal();
                }
            });
        }
        
        const sidePanel = document.getElementById('side-panel');
        const modalBody = document.getElementById('analysis-modal-body');
        if (sidePanel && modalBody) {
            modalBody.innerHTML = sidePanel.innerHTML;
        }
        
        modal.style.display = 'block';
    }

    hideAnalysisModal() {
        const modal = document.getElementById('analysis-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    // Смена символа
    async switchSymbol(newSymbol) {
        if (newSymbol === this.currentSymbol) return;
        
        console.log(`🔄 Смена символа: ${this.currentSymbol} -> ${newSymbol}`);
        
        // Останавливаем старые обновления
        this.chartUpdater.stop();
        
        // Сбрасываем флаг проверки свежести
        this.dataInitiallyLoaded = false;
        
        this.currentSymbol = newSymbol;
        
        // Очищаем ВСЕ данные
        this.clearSelection();
        this.patternMarkers.clear();
        this.matchedHighlightPoints = [];
        this.matchedRanges = [];
        this.currentMatchIndex = -1;
        
        // Очищаем график
        this.candleSeries.setData([]);
        this.volumeSeries.setData([]);
        
        // Показываем загрузку
        const loader = this.ensureLoader();
        loader.style.display = 'flex';
        
        try {
            // Обновляем заголовок страницы
            const symbolDisplay = newSymbol.replace('#', '/');
            document.getElementById('page-title').textContent = `${symbolDisplay} — Поиск паттернов`;
            
            // ПЕРЕЗАГРУЖАЕМ ДАННЫЕ С НОВЫМ СИМВОЛОМ
            await this.loadData();
            
            // Сбрасываем UI
            safeSetTextContent('matches-found', '0');
            safeSetTextContent('pattern-length', '0');
            safeSetTextContent('accuracy', '0%');
            safeSetStyle('pattern-info-card', 'display', 'none');
            safeSetInnerHTML('matches', '');
            safeSetInnerHTML('general-analysis-card', '');
            
            this.toast(`Загружены данные для ${symbolDisplay}`);
            
            // ЗАПУСКАЕМ СИСТЕМУ ОБНОВЛЕНИЙ ДЛЯ НОВОГО СИМВОЛА
            this.chartUpdater.initialize(this.currentSymbol, this.currentTimeframe);
            
        } catch (e) {
            console.error('❌ Ошибка смены символа:', e);
            this.toast('Ошибка загрузки данных: ' + e.message);
        } finally {
            loader.style.display = 'none';
        }
    }
 
    // Смена таймфрейма
    async switchTimeframe(newTimeframe) {
        console.log(`🔄 Смена таймфрейма: ${this.currentTimeframe} -> ${newTimeframe}`);
        
        // Останавливаем старые обновления
        this.chartUpdater.stop();
        
        // Сбрасываем флаг проверки свежести
        this.dataInitiallyLoaded = false;
        
        this.currentTimeframe = newTimeframe;
        
        // Очищаем ВСЕ данные
        this.clearSelection();
        this.patternMarkers.clear();
        this.matchedHighlightPoints = [];
        this.matchedRanges = [];
        this.currentMatchIndex = -1;
        
        // Очищаем график
        this.candleSeries.setData([]);
        this.volumeSeries.setData([]);
        
        // Показываем загрузку
        const loader = this.ensureLoader();
        loader.style.display = 'flex';
        
        try {
            // ПЕРЕЗАГРУЖАЕМ ДАННЫЕ С НОВЫМ ТАЙМФРЕЙМОМ
            await this.loadData();
            
            // Сбрасываем UI
            safeSetTextContent('matches-found', '0');
            safeSetTextContent('pattern-length', '0');
            safeSetTextContent('accuracy', '0%');
            safeSetStyle('pattern-info-card', 'display', 'none');
            safeSetInnerHTML('matches', '');
            safeSetInnerHTML('general-analysis-card', '');
            
            // Обновляем отображение таймфрейма
            const timeframeMap = {
                '1h': '1ч',
                '4h': '4ч', 
                '1d': '1Д',
                '1w': '1Н'
            };
            const kpiTF = document.querySelector('.kpi strong');
            if (kpiTF) kpiTF.textContent = timeframeMap[newTimeframe] || newTimeframe;
            
            this.toast(`Загружены данные для таймфрейма ${timeframeMap[newTimeframe] || newTimeframe}`);
            
            // ЗАПУСКАЕМ СИСТЕМУ ОБНОВЛЕНИЙ ДЛЯ НОВОГО ТАЙМФРЕЙМА
            this.chartUpdater.initialize(this.currentSymbol, this.currentTimeframe);
            
        } catch (e) {
            console.error('❌ Ошибка смены таймфрейма:', e);
            this.toast('Ошибка загрузки данных: ' + e.message);
        } finally {
            loader.style.display = 'none';
        }
    }
    switchToAnalysisMode() {
        this.isAnalysisMode = true;
        this.chart.applyOptions({
            timeScale: {
                minBarSpacing: 2,
                barSpacing: 12
            }
        });
        this.updateSelected();
    }

    switchToSelectionMode() {
        this.isAnalysisMode = false;
        this.chart.applyOptions({
            timeScale: {
                minBarSpacing: 15,
                barSpacing: 60
            }
        });
        this.chart.timeScale().fitContent();
    }

    setActiveTimeframe() {
        document.querySelectorAll('[data-tf]').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-tf') === this.currentTimeframe) {
                btn.classList.add('active');
            }
        });
        
        const timeframeMap = {
            '1h': '1ч',
            '4h': '4ч',
            '1d': '1Д', 
            '1w': '1Н'
        };
        const kpiTF = document.querySelector('.kpi strong');
        if (kpiTF) kpiTF.textContent = timeframeMap[this.currentTimeframe] || this.currentTimeframe;
    }

    // Ручное обновление данных
    async manualRefreshData() {
        const loader = this.ensureLoader();
        loader.style.display = 'flex';
        
        try {
            await this.chartUpdater.manualRefresh();
            this.toast('✅ Данные успешно обновлены');
        } catch (error) {
            console.error('❌ Ошибка ручного обновления:', error);
            this.toast('❌ Ошибка обновления данных');
        } finally {
            loader.style.display = 'none';
        }
    }
}

// Вспомогательные функции
function safeSetTextContent(elementId, text) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = text;
    }
}

function safeSetInnerHTML(elementId, html) {
    const element = document.getElementById(elementId);
    if (element) {
        element.innerHTML = html;
    }
}

function safeSetStyle(elementId, property, value) {
    const element = document.getElementById(elementId);
    if (element) {
        element.style[property] = value;
    }
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => new PatternChart());
    </script>
</body>
</html>

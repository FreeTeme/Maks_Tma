<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT — Поиск паттернов</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-0: #0f1419;
            --bg-1: #11161c;
            --bg-2: #131a21;
            --bg-3: #0b1015;
            --panel: #0f151b;
            --border: #1c2631;
            --muted: #8b99a8;
            --text: #e5edf5;
            --accent: #f7931a;
            --green: #22c55e;
            --red: #ef4444;
        }

        html, body { 
            height: 100%; 
            margin: 0;
            padding: 0;
        }
        body {
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 600px at 20% -10%, #0b1117 0%, #0a0f14 45%, #070b0f 100%);
            color: var(--text);
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(17,22,28,0.85), rgba(17,22,28,0.65));
            backdrop-filter: blur(6px);
            flex-shrink: 0;
        }
        .brand { display: flex; align-items: center; gap: 10px; }
        .back-btn {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }
        .back-btn:hover {
            background: #212a34;
            color: var(--accent);
        }
        .brand .logo {
            width: 24px; height: 24px; border-radius: 6px;
            background: linear-gradient(135deg, #ffb547, #f7931a);
            box-shadow: 0 2px 8px rgba(247,147,26,0.35);
        }
        .brand .title { 
            font-weight: 700; 
            letter-spacing: 0.2px; 
            font-size: 15px;
        }
        .kpis { 
            display: flex; 
            gap: 12px; 
            align-items: center;
            font-size: 12px;
        }
        .kpi { font-size: 11px; color: var(--muted); }
        .kpi strong { color: var(--text); margin-left: 4px; }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .panel { 
            background: var(--panel); 
            border: 1px solid var(--border); 
            border-radius: 12px; 
            overflow: hidden;
            flex: 1;
            margin: 12px;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, var(--bg-2), var(--bg-3));
            flex-shrink: 0;
        }
        .left-tools, .right-tools { display: flex; gap: 6px; align-items: center; }
        .left-tools { justify-content: space-between; width: 100%; flex-wrap: wrap; }
        .right-tools { flex-wrap: nowrap; }
        .btn {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.15s ease;
            white-space: nowrap;
        }
        .tf .btn { flex: 1; }
        .btn:hover { background: #212a34; }
        .btn.primary { background: var(--accent); border-color: #ffb547; color: #0c0f12; font-weight: 600; }
        .btn.primary:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.analyze { 
            background: #22c55e !important; 
            border-color: #16a34a !important; 
            color: #ffffff !important; 
            font-weight: 600; 
            padding: 8px 12px; 
            font-size: 13px; 
        }
        .btn.analyze:disabled { 
            opacity: 0.5; 
            cursor: not-allowed; 
            background: #22c55e !important; 
        }
        .btn.analyze:hover { 
            background: #16a34a !important; 
            border-color: #15803d !important;
        }
        .btn.clear { 
            background: #dc2626 !important; 
            border-color: #b91c1c !important; 
            color: #ffffff !important; 
            font-weight: 600; 
        }
        .btn.clear:hover { 
            background: #b91c1c !important; 
            border-color: #991b1b !important;
        }
        .tf { display: flex; gap: 6px; flex: 1; }
        .tf .btn.active { background: #2a3542; border-color: #334153; }
        .sep { width: 1px; height: 22px; background: var(--border); }
        .counter { font-size: 12px; color: var(--muted); }
        .counter strong { color: var(--text); }

        .chart-wrap { 
            position: relative; 
            flex: 1; 
            min-height: 300px; 
        }
        #chart { 
            width: 100%; 
            height: 100%; 
            touch-action: pan-x pan-y pinch-zoom;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .side {
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 0 12px 60px;
            overflow-y: auto;
        }
        .side.active {
            display: flex;
        }
        .card { 
            background: var(--panel); 
            border: 1px solid var(--border); 
            border-radius: 10px; 
            padding: 10px; 
        }
        .card h3 { margin: 0 0 6px; font-size: 13px; color: var(--muted); font-weight: 600; }
        .stat-list { display: grid; gap: 6px; }
        .stat { display: flex; justify-content: space-between; font-size: 12px; }
        .stat .val { color: var(--text); font-weight: 600; }

        .matches { display: grid; gap: 8px; }
        .match {
            border: 1px solid var(--border);
            border-radius: 8px; 
            padding: 8px;
            background: #0f151b;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .match:hover { 
            background: #131a21; 
            border-color: #2a3847; 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .match::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s ease;
        }
        .match:hover::before {
            left: 100%;
        }
        .match.active {
            background: linear-gradient(135deg, #1a222c, #131a21);
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(247, 147, 26, 0.3);
            transform: translateY(-2px);
        }
        .match.active::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--accent);
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Индикатор активных выбранных свечей */
        .selected-candles-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
            z-index: 1000;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 6px 16px rgba(255, 107, 53, 0.6); }
            100% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4); }
        }
        .match .hdr { display: flex; justify-content: space-between; align-items: center; }
        .match .range { font-size: 11px; color: var(--muted); }
        .badge { 
            padding: 4px 8px; 
            border-radius: 999px; 
            font-size: 11px; 
            font-weight: 700; 
            border: 1px solid transparent;
            transition: all 0.3s ease;
        }
        .badge.up { 
            background: linear-gradient(135deg, rgba(34,197,94,0.2), rgba(34,197,94,0.1)); 
            color: var(--green); 
            border-color: rgba(34,197,94,0.3);
            box-shadow: 0 2px 8px rgba(34,197,94,0.2);
        }
        .badge.down { 
            background: linear-gradient(135deg, rgba(239,68,68,0.2), rgba(239,68,68,0.1)); 
            color: var(--red); 
            border-color: rgba(239,68,68,0.3);
            box-shadow: 0 2px 8px rgba(239,68,68,0.2);
        }

        .footer-note { font-size: 11px; color: var(--muted); text-align: center; padding-top: 4px; }
        
        /* Общий анализ паттернов */
        .pattern-distribution {
            margin: 12px 0;
            display: grid;
            gap: 8px;
        }
        
        .distribution-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .distribution-label {
            flex: 1;
            color: var(--muted);
            font-weight: 500;
        }
        
        .distribution-bar {
            flex: 2;
            height: 8px;
            background: var(--bg-2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .distribution-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.8s ease;
            position: relative;
        }
        
        .distribution-fill.bullish {
            background: linear-gradient(90deg, #22c55e, #16a34a);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);
        }
        
        .distribution-fill.bearish {
            background: linear-gradient(90deg, #ef4444, #dc2626);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.3);
        }
        
        .distribution-value {
            min-width: 30px;
            text-align: right;
            color: var(--text);
            font-weight: 600;
            font-size: 11px;
        }
        
        /* Недавние паттерны */
        .recent-patterns {
            display: grid;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .recent-pattern {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .recent-pattern:hover {
            background: var(--bg-3);
            border-color: #334153;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .recent-pattern::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 0.5s ease;
        }
        
        .recent-pattern:hover::before {
            left: 100%;
        }
        
        .recent-pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .recent-pattern-dates {
            font-size: 11px;
            color: var(--muted);
        }
        
        .recent-pattern-direction {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .recent-pattern-direction.bullish {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        
        .recent-pattern-direction.bearish {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .recent-pattern-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }
        
        .recent-pattern-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .recent-pattern-stat-label {
            color: var(--muted);
        }
        
        .recent-pattern-stat-value {
            color: var(--text);
            font-weight: 600;
        }
        
        .recent-pattern-stat-value.positive {
            color: var(--green);
        }
        
        .recent-pattern-stat-value.negative {
            color: var(--red);
        }
        
        /* Анимация загрузки для общего анализа */
        .general-analysis-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--muted);
        }
        
        .general-analysis-loading i {
            margin-right: 8px;
            animation: spin 1s linear infinite;
        }
        
        /* Мини-график */
        .mini-chart-container {
            margin: 12px 0;
            padding: 8px;
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 8px;
            text-align: center;
        }
        
        .mini-chart-container canvas {
            border-radius: 4px;
            background: var(--bg-3);
        }
        
        .mini-chart-label {
            font-size: 10px;
            color: var(--muted);
            margin-top: 4px;
            font-weight: 500;
        }
        
        /* Статистика производительности */
        .performance-summary {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            display: grid;
            gap: 8px;
        }
        
        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .summary-label {
            color: var(--muted);
            font-weight: 500;
        }
        
        .summary-value {
            font-weight: 600;
            font-size: 13px;
        }
        
        .summary-value.bullish {
            color: var(--green);
        }
        
        .summary-value.bearish {
            color: var(--red);
        }

        
        .chart-controls {
            display: none;
            position: absolute;
            bottom: 12px;
            left: 12px;
            right: 12px;
            background: rgba(17, 22, 28, 0.95);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 12px;
            z-index: 50;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        .chart-controls.visible {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }
        .chart-controls.collapsed {
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .chart-controls.collapsed .control-btn {
            display: none;
        }
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 14px;
            background: #1a222c;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
            flex: 1;
        }
        .control-btn:hover {
            background: #212a34;
            border-color: #334153;
        }
        .control-btn i {
            font-size: 14px;
            width: 18px;
            text-align: center;
        }
        .toggle-controls-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: var(--accent);
            border: 1px solid #ffb547;
            border-radius: 8px;
            color: #0c0f12;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            min-width: 38px;
            flex-shrink: 0;
        }
        .toggle-controls-btn:hover {
            background: #ffb547;
        }
        .chart-controls.collapsed .toggle-controls-btn {
            border-radius: 50%;
            width: 100%;
            height: 100%;
            min-width: 48px;
        }

        /* Mobile bottom navigation */
        .mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-1);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 12px 16px;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(17, 22, 28, 0.9);
        }
        .nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 24px;
            font-size: 13px;
            color: #ffffff;
            background: none;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
            font-weight: 600;
        }
        .nav-btn.active {
            color: var(--accent);
            background: rgba(247, 147, 26, 0.1);
        }
        .nav-btn i {
            font-size: 20px;
            margin-bottom: 4px;
        }
        #nav-analysis {
            background: #22c55e !important;
            border: 1px solid #16a34a;
        }
        #nav-analysis:hover {
            background: #16a34a !important;
        }
        #nav-volume {
            background: #1a222c !important;
            border: 1px solid var(--border);
        }
        #nav-volume:hover {
            background: #212a34 !important;
        }
        #nav-clear {
            background: #dc2626 !important;
            border: 1px solid #b91c1c;
        }
        #nav-clear:hover {
            background: #b91c1c !important;
        }

        /* Modal for patterns */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(7, 11, 15, 0.9);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: var(--panel);
            border-radius: 12px;
            padding: 16px;
            max-width: 500px;
            margin: 0 auto;
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }
        
        /* Clear Modal Styles */
        .clear-modal-content {
            max-width: 450px;
            text-align: center;
        }
        
        .clear-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.3);
        }
        
        .clear-icon i {
            font-size: 32px;
            color: #ffffff;
        }
        
        .clear-modal-content h3 {
            margin: 0 0 12px;
            font-size: 20px;
            font-weight: 600;
            color: var(--text);
        }
        
        .clear-modal-content p {
            margin: 0 0 24px;
            font-size: 14px;
            color: var(--muted);
            line-height: 1.5;
        }
        
        .clear-stats {
            background: var(--bg-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin: 0 0 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .stat-label {
            font-size: 12px;
            color: var(--muted);
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
        }
        
        .clear-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .btn.clear-confirm {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            border: none;
            color: #ffffff;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
        }
        
        .btn.clear-confirm:hover {
            background: linear-gradient(135deg, #b91c1c, #991b1b);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(220, 38, 38, 0.4);
        }
        
        .btn.clear-cancel {
            background: var(--bg-2);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        
        .btn.clear-cancel:hover {
            background: var(--bg-3);
            border-color: #334153;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        .modal-title {
            font-weight: 600;
            font-size: 16px;
        }
        .close-modal {
            background: none;
            border: none;
            color: var(--muted);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .close-modal:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--red);
        }

        /* Overlay + toast */
        .loading {
            position: fixed; 
            inset: 0; 
            display: none; 
            align-items: center; 
            justify-content: center;
            background: rgba(3,6,9,0.55); 
            backdrop-filter: blur(2px); 
            z-index: 50;
        }
        .spinner { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 3px solid rgba(255,255,255,0.12); 
            border-top-color: var(--accent); 
            animation: spin 0.9s linear infinite; 
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .toast { 
            position: fixed; 
            bottom: 70px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: #111821; 
            border: 1px solid #223041; 
            color: #e3edf7; 
            padding: 10px 14px; 
            border-radius: 10px; 
            font-size: 13px; 
            display: none; 
            z-index: 60;
            max-width: 80%;
            text-align: center;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .app {
                display: grid;
                grid-template-rows: auto 1fr;
            }
            
            .main {
                display: grid;
                grid-template-columns: 1fr 320px;
                gap: 12px;
                padding: 12px;
                overflow: hidden;
            }
            
            .panel {
                margin: 0;
            }
            
            .side {
                display: flex;
                padding: 0;
                overflow-y: auto;
            }
            
            .mobile-nav {
                display: none;
            }
            
            .topbar {
                padding: 16px 20px;
            }
            
            .brand .logo {
                width: 28px; 
                height: 28px;
            }
            
            .brand .title {
                font-size: 16px;
            }
            
            .kpis {
                gap: 16px;
                font-size: 13px;
            }
            
            .toolbar {
                padding: 10px 12px;
            }
            
            .btn {
                padding: 8px 10px;
                font-size: 13px;
            }
        }

        @media (max-width: 768px) {
            .chart-controls {
                bottom: 80px;
            }
            
            .chart-controls.collapsed {
                bottom: 80px;
            }
            
            .control-btn span {
                display: none;
            }
            
            .control-btn {
                padding: 8px;
                min-width: 40px;
                justify-content: center;
            }
            
            /* Hide desktop action buttons on mobile (use mobile-nav instead) */
            #toggle-volume-btn, #analyze-btn, #clear-btn {
                display: none !important;
            }
        }

        @media (max-width: 380px) {
            .toolbar {
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .left-tools, .right-tools {
                flex-wrap: wrap;
            }
            
            .btn {
                font-size: 11px;
                padding: 5px 6px;
            }
            
            .counter {
                font-size: 11px;
            }
            
            .chart-controls {
                gap: 6px;
                padding: 8px;
                left: 8px;
                right: 8px;
            }
            
            .chart-controls.collapsed {
                width: 44px;
                height: 44px;
            }
            
            .control-btn {
                padding: 6px;
                min-width: 36px;
            }
            
            .toggle-controls-btn {
                padding: 6px;
                min-width: 34px;
                font-size: 14px;
            }
            
            .chart-controls.collapsed .toggle-controls-btn {
                min-width: 44px;
            }
        }

        .symbol-selector {
            margin-left: 15px;
        }

        .symbol-select {
            background: #1a222c;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            min-width: 120px;
        }

        .symbol-select option {
            background: var(--bg-2);
            color: var(--text);
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="topbar">
            <div class="brand">
                <button class="back-btn" onclick="history.back()" title="Назад">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="logo"></div>
                <!-- В разделе .brand, после .title -->
                <div class="title" id="page-title">BTC/USDT — Поиск паттернов</div>
                <div class="symbol-selector">
                    <select id="symbol-select" class="symbol-select">
                        <option value="BTC#USDT">BTC/USDT</option>
                        <option value="ETH#USDT">ETH/USDT</option>
                        <option value="XRP#USDT">XRP/USDT</option>
                        <option value="SOL#USDT">SOL/USDT</option>
                        <option value="BNB#USDT">BNB/USDT</option>
                        <option value="TRX#USDT">TRX/USDT</option>
                        <option value="ADA#USDT">ADA/USDT</option>
                        <option value="SUI#USDT">SUI/USDT</option>
                        <option value="LINK#USDT">LINK/USDT</option>
                        <option value="LTC#USDT">LTC/USDT</option>
                        <option value="TON#USDT">TON/USDT</option>
                    </select>
                </div>
            </div>
            <div class="kpis">
                <div class="kpi">ТФ:<strong>1D</strong></div>
                <div class="kpi">Данные:<strong>2017→</strong></div>
            </div>
        </div>

        <div class="main">
            <div class="panel">
                <div class="toolbar">
                    <div class="left-tools">
                        <div class="tf">
                            <button class="btn" data-tf="1h">1 час</button>
                            <button class="btn" data-tf="4h">4 часа</button>
                            <button class="btn active" data-tf="1d">1 день</button>
                            <button class="btn" data-tf="1w">1 неделя</button>
                        </div>
                        <div class="right-tools">
                            <button id="toggle-volume-btn" class="btn" title="Показать/скрыть объем">
                                <i class="fas fa-chart-bar"></i> Объем
                            </button>
                            <button id="reset-view-btn" class="btn">Сброс</button>
                            <button id="analyze-btn" class="btn analyze" disabled>
                                <i class="fas fa-chart-line"></i> Анализ
                            </button>
                            <button id="clear-btn" class="btn clear">
                                <i class="fas fa-trash"></i> Очистить
                            </button>
                        </div>
                    </div>
                </div>
                <div class="chart-wrap">
                    <div id="chart"></div>
                    <!-- Chart Controls Overlay -->
                    <div class="chart-controls" id="chart-controls">
                        <button class="control-btn" id="nav-prev">
                            <i class="fas fa-chevron-left"></i>
                            <span>Назад</span>
                        </button>
                        <button class="control-btn" id="nav-next">
                            <i class="fas fa-chevron-right"></i>
                            <span>Вперед</span>
                        </button>
                        <button class="control-btn" id="nav-to-selected">
                            <i class="fas fa-search"></i>
                            <span>К выбранным</span>
                        </button>
                        <button class="control-btn" id="nav-volume-overlay">
                            <i class="fas fa-chart-bar"></i>
                            <span>Объем</span>
                        </button>
                        <button class="control-btn" id="nav-patterns">
                            <i class="fas fa-shapes"></i>
                            <span>Паттерны</span>
                        </button>
                        <button class="toggle-controls-btn" id="toggle-controls-btn" title="Свернуть/Развернуть">
                            <i class="fas fa-chevron-down"></i>
                        </button>
                    </div>
                </div>
            </div>

            <div class="side" id="side-panel">
                <!-- Общий анализ паттернов -->
                <div class="card" id="general-analysis-card">
                    <h3>Общий анализ рынка</h3>
                    <div class="stat-list" id="general-stats">
                        <div class="stat"><span>Всего свечей</span><span class="val" id="total-candles">-</span></div>
                        <div class="stat"><span>Период данных</span><span class="val" id="data-period">-</span></div>
                        <div class="stat"><span>Волатильность</span><span class="val" id="volatility">-</span></div>
                        <div class="stat"><span>Средний объем</span><span class="val" id="avg-volume">-</span></div>
                    </div>
                    <div class="pattern-distribution">
                        <div class="distribution-item">
                            <span class="distribution-label">Бычьи паттерны</span>
                            <div class="distribution-bar">
                                <div class="distribution-fill bullish" id="bullish-bar"></div>
                            </div>
                            <span class="distribution-value" id="bullish-count">0</span>
                        </div>
                        <div class="distribution-item">
                            <span class="distribution-label">Медвежьи паттерны</span>
                            <div class="distribution-bar">
                                <div class="distribution-fill bearish" id="bearish-bar"></div>
                            </div>
                            <span class="distribution-value" id="bearish-count">0</span>
                        </div>
                    </div>
                    <div class="mini-chart-container" id="mini-chart-container" style="display: none;">
                        <canvas id="mini-chart" width="280" height="80"></canvas>
                        <div class="mini-chart-label">Тренд цены (последние 30 дней)</div>
                    </div>
                    <button class="btn analyze" id="load-general-analysis" style="width: 100%; margin-top: 10px;">
                        <i class="fas fa-chart-pie"></i> Анализ выбранных свечей
                    </button>
                </div>
                
                <!-- Недавние паттерны -->
                <div class="card" id="recent-patterns-card" style="display:none">
                    <h3>Недавние паттерны</h3>
                    <div class="recent-patterns" id="recent-patterns-list"></div>
                </div>
                
                <div class="card">
                    <h3>Итоги анализа</h3>
                    <div class="stat-list">
                        <div class="stat"><span>Найдено совпадений</span><span class="val" id="matches-found">0</span></div>
                        <div class="stat"><span>Длина паттерна</span><span class="val" id="pattern-length">0</span></div>
                        <div class="stat"><span>Средняя точность</span><span class="val" id="accuracy">0%</span></div>
                    </div>
                    <div class="footer-note">Выберите 1–6 свечей на графике и запустите анализ</div>
                </div>
                <div class="card" id="pattern-info-card" style="display:none">
                    <h3>Паттерн</h3>
                    <div class="stat-list" id="pattern-info"></div>
                </div>
                <div class="card">
                    <h3>Совпадения</h3>
                    <div class="matches" id="matches"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Navigation -->
    <div class="mobile-nav">
        <button class="nav-btn" id="nav-volume">
            <i class="fas fa-chart-bar"></i>
            <span>Объем</span>
        </button>
        <button class="nav-btn" id="nav-analysis">
            <i class="fas fa-chart-line"></i>
            <span>Анализ</span>
        </button>
        <button class="nav-btn" id="nav-clear">
            <i class="fas fa-trash"></i>
            <span>Очистить</span>
        </button>
    </div>

    <!-- Patterns Modal -->
    <div class="modal" id="patterns-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Найденные паттерны</div>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="pattern-stats" id="modal-pattern-stats" style="margin-bottom: 16px; padding: 12px; background: var(--bg-2); border-radius: 8px; border: 1px solid var(--border);">
                    <!-- Pattern statistics will be inserted here -->
                </div>
                <div id="modal-patterns-list">
                    <!-- Patterns will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Clear Confirmation Modal -->
    <div class="modal" id="clear-confirmation-modal">
        <div class="modal-content clear-modal-content">
            <div class="modal-header">
                <div class="modal-title">
                    <i class="fas fa-trash-alt" style="margin-right: 8px; color: #dc2626;"></i>
                    Очистка выбора
                </div>
                <button class="close-modal" id="close-clear-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="clear-modal-content">
                    <div class="clear-icon">
                        <i class="fas fa-sync-alt"></i>
                    </div>
                    <h3>Обновить страницу?</h3>
                    <p>Это действие обновит страницу и сбросит все выбранные свечи и анализ. Вы сможете начать заново.</p>
                    <div class="clear-stats" id="clear-stats">
                        <div class="stat-item">
                            <span class="stat-label">Выбрано свечей:</span>
                            <span class="stat-value" id="selected-count-modal">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Найдено паттернов:</span>
                            <span class="stat-value" id="patterns-count-modal">0</span>
                        </div>
                    </div>
                    <div class="clear-actions">
                        <button class="btn clear-confirm" id="confirm-clear-btn">
                            <i class="fas fa-sync-alt"></i>
                            <span>Да, обновить</span>
                        </button>
                        <button class="btn clear-cancel" id="cancel-clear-btn">
                            <i class="fas fa-times"></i>
                            <span>Отмена</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
		// Вспомогательная функция для безопасного обновления textContent
		function safeSetTextContent(elementId, text) {
			const element = document.getElementById(elementId);
			if (element) {
				element.textContent = text;
			} else {
				console.warn(`Элемент с ID '${elementId}' не найден`);
			}
		}

		// Безопасная функция для обновления innerHTML
		function safeSetInnerHTML(elementId, html) {
			const element = document.getElementById(elementId);
			if (element) {
				element.innerHTML = html;
			} else {
				console.warn(`Элемент с ID '${elementId}' не найден`);
			}
		}

		// Безопасная функция для установки стилей
		function safeSetStyle(elementId, property, value) {
			const element = document.getElementById(elementId);
			if (element) {
				element.style[property] = value;
			} else {
				console.warn(`Элемент с ID '${elementId}' не найден`);
			}
		}

		class PatternChart {
            constructor() {
                this.chart = null;
                this.candleSeries = null;
                this.volumeSeries = null;
                this.volumeVisible = true;
                this.allCandles = [];
				this.selectedIndices = new Set();
				this.selectedMarkers = new Map();
				this.patternMarkers = new Map();
				
				// Восстанавливаем сохраненный таймфрейм или используем по умолчанию
				const savedTimeframe = localStorage.getItem('savedTimeframe');
				this.currentTimeframe = savedTimeframe || '1d';
				
				// Очищаем сохраненный таймфрейм после использования
				if (savedTimeframe) {
					localStorage.removeItem('savedTimeframe');
				}

                const savedSymbol = localStorage.getItem('savedSymbol');
                this.currentSymbol = savedSymbol || 'BTC#USDT';
                
                // Очищаем сохраненный символ после использования
                if (savedSymbol) {
                    localStorage.removeItem('savedSymbol');
                }
				
                this.initChart();
                this.loadData();
				this.bindUI();
				this.toastEl = null;
				this.overlay = null;
				this.matchedHighlightPoints = [];
				this.selectedHighlightPoints = [];
				this.currentMatchIndex = -1;
				this.matchedRanges = [];
				this.isAnalysisMode = false; // Режим: false = выбор свечей, true = просмотр результатов
            }

            async switchSymbol(newSymbol) {
                if (newSymbol === this.currentSymbol) return;
                
                // Сохраняем новый символ
                this.currentSymbol = newSymbol;
                
                // Обновляем заголовок страницы
                this.updatePageTitle();
                
                // Очищаем текущие данные
                this.clearSelection();
                this.patternMarkers.clear();
                this.matchedHighlightPoints = [];
                this.matchedRanges = [];
                this.currentMatchIndex = -1;
                
                // Показываем загрузку
                const loader = this.ensureLoader();
                loader.style.display = 'flex';
                
                try {
                    // Перезагружаем данные с новым символом
                    await this.loadData();
                    
                    // Обновляем UI
                    safeSetTextContent('matches-found', '0');
                    safeSetTextContent('pattern-length', '0');
                    safeSetTextContent('accuracy', '0%');
                    safeSetStyle('pattern-info-card', 'display', 'none');
                    safeSetInnerHTML('matches', '');
                    
                    this.toast(`Загружены данные для ${newSymbol.replace('#', '/')}`);
                } catch (e) {
                    this.toast('Ошибка загрузки данных: ' + e.message);
                } finally {
                    loader.style.display = 'none';
                }
            }

            updatePageTitle() {
                const titleElement = document.getElementById('page-title');
                if (titleElement) {
                    titleElement.textContent = `${this.currentSymbol.replace('#', '/')} — Поиск паттернов`;
                }
            }

            initChart() {
				const el = document.getElementById('chart');
				this.chart = LightweightCharts.createChart(el, {
					width: el.clientWidth,
					height: el.clientHeight,
					layout: { backgroundColor: '#0a0f14', textColor: '#d6dee6', fontFamily: 'Inter' },
					grid: { vertLines: { color: 'rgba(32,42,54,0.85)' }, horzLines: { color: 'rgba(32,42,54,0.85)' } },
					crosshair: { mode: LightweightCharts.CrosshairMode.Magnet, vertLine: { color: '#3a4654' }, horzLine: { color: '#3a4654' } },
					rightPriceScale: { borderColor: '#243142' },
					timeScale: { 
						borderColor: '#243142', 
						rightOffset: 6, 
						barSpacing: 60, // Увеличено для сильного начального приближения
						minBarSpacing: 15, // Средняя чувствительность для режима выбора
						fixLeftEdge: false,
						fixRightEdge: false,
						lockVisibleTimeRangeOnResize: true,
						shiftVisibleRangeOnNewBar: true,
						timeVisible: true,
						secondsVisible: false
					},
					handleScroll: { 
						mouseWheel: true, 
						pressedMouseMove: true,
						horzTouchDrag: true,
						vertTouchDrag: true
					},
					handleScale: { 
						axisPressedMouseMove: { time: true, price: true },
						axisDoubleClickReset: { time: true, price: true },
						mouseWheel: true,
						pinch: true
					},
					kineticScroll: {
						touch: true,
						mouse: false
					}
                });
                
                // Увеличиваем чувствительность масштабирования колёсиком мыши
                const timeScale = this.chart.timeScale();
                const originalScrollPosition = timeScale.scrollPosition.bind(timeScale);
                const originalScrollToPosition = timeScale.scrollToPosition.bind(timeScale);
                
                // Перехватываем события колёсика для управления чувствительностью
                el.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        // Масштабирование с зажатым Ctrl/Cmd
                        e.preventDefault();
                        const delta = e.deltaY;
                        const currentRange = timeScale.getVisibleLogicalRange();
                        if (currentRange) {
                            const center = (currentRange.from + currentRange.to) / 2;
                            // В режиме анализа - высокая чувствительность, в режиме выбора - средняя
                            const scaleFactor = this.isAnalysisMode 
                                ? (delta > 0 ? 1.15 : 0.85)  // Высокая чувствительность
                                : (delta > 0 ? 1.08 : 0.92); // Средняя чувствительность
                            const newRange = {
                                from: center - (center - currentRange.from) * scaleFactor,
                                to: center + (currentRange.to - center) * scaleFactor
                            };
                            timeScale.setVisibleLogicalRange(newRange);
                        }
                    }
                }, { passive: false });
                
                // Улучшенная обработка тач-жестов для большей чувствительности
                let touchStartDistance = 0;
                let touchStartRange = null;
                
                el.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        touchStartDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        touchStartRange = timeScale.getVisibleLogicalRange();
                    }
                }, { passive: true });
                
                el.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && touchStartRange) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (touchStartDistance > 0) {
                            const scaleFactor = currentDistance / touchStartDistance;
                            const rangeSize = touchStartRange.to - touchStartRange.from;
                            const center = (touchStartRange.from + touchStartRange.to) / 2;
                            // В режиме анализа - высокая чувствительность, в режиме выбора - средняя
                            const sensitivity = this.isAnalysisMode ? 1.3 : 1.05;
                            const newRangeSize = rangeSize / (scaleFactor * sensitivity);
                            
                            const newRange = {
                                from: center - newRangeSize / 2,
                                to: center + newRangeSize / 2
                            };
                            
                            timeScale.setVisibleLogicalRange(newRange);
                        }
                    }
                }, { passive: true });
                
                el.addEventListener('touchend', () => {
                    touchStartDistance = 0;
                    touchStartRange = null;
                }, { passive: true });

                this.candleSeries = this.chart.addCandlestickSeries({
					upColor: '#21d07a',
					downColor: '#f04444',
					borderUpColor: '#1ac46f',
					borderDownColor: '#e73c3c',
					wickUpColor: '#24e084',
					wickDownColor: '#ff5050',
                    priceLineVisible: false,
                });
                this.volumeSeries = this.chart.addHistogramSeries({
                    priceScaleId: '',
					scaleMargins: { top: 0.85, bottom: 0 },
					priceFormat: { type: 'volume' },
				});

				this.chart.subscribeClick(this.onClick.bind(this));
				window.addEventListener('resize', () => { this.chart.applyOptions({ width: el.clientWidth }); this.resizeOverlay(); this.redrawOverlay(); });
				this.ensureOverlay();
				
				// Подписываемся на изменения видимого диапазона с задержкой для стабильности
				this.chart.timeScale().subscribeVisibleTimeRangeChange(() => {
					setTimeout(() => this.redrawOverlay(), 10);
				});
				
				// Добавляем анимацию для пульсирующего эффекта
				this.animationFrame = null;
				this.startAnimation();
            }

            async loadData() {
                try {
                    // Узнаём реальные границы датасета на сервере и синхронизируемся
                    let dsStart = new Date('2018-01-01T00:00:00Z');
                    let dsEnd = new Date();
                    try {
                        const b = await fetch(`/api/pattern/bounds?timeframe=${this.currentTimeframe}&symbol=${this.currentSymbol}`);
                        if (b.ok) {
                            const j = await b.json();
                            if (j.success) { 
                                dsStart = new Date(j.start + 'T00:00:00Z'); 
                                dsEnd = new Date(j.end + 'T23:59:59Z'); 
                            }
                        }
                    } catch(_) {}
                    
                    this.datasetStart = dsStart; 
                    this.datasetEnd = dsEnd;
                    
                    // Добавляем 1 день к конечной дате
                    const nextDay = new Date(dsEnd);
                    nextDay.setDate(dsEnd.getDate() + 1);
                    
                    // Загружаем реальные свечи с сервера
                    const api = await fetch(
                        `/api/pattern/ohlcv?source=binance` +
                        `&from=${dsStart.toISOString().slice(0,10)}` +
                        `&to=${nextDay.toISOString().slice(0,10)}` +
                        `&timeframe=${this.currentTimeframe}` +
                        `&symbol=${this.currentSymbol}`  // ← добавить эту строку
                    );
                    
                    if (!api.ok) throw new Error('Не удалось загрузить OHLCV');
                    const aj = await api.json();
                    if (!aj.success) throw new Error(aj.message || 'Ошибка загрузки OHLCV');
                    this.allCandles = aj.candles || [];

                    if (!Array.isArray(this.allCandles) || this.allCandles.length === 0) {
                        throw new Error('Пустой набор свечей');
                    }
                    
                    // Нормализация типов
                    this.allCandles = this.allCandles.map(c => ({
                        open_time: c.open_time,
                        close_time: c.close_time,
                        open_price: Number(c.open_price),
                        close_price: Number(c.close_price),
                        high: Number(c.high),
                        low: Number(c.low),
                        volume: Number(c.volume),
                    }));
                    
                    const k = this.allCandles.map(c => ({
                        time: Math.floor(new Date(c.open_time).getTime() / 1000),
                        open: c.open_price, high: c.high, low: c.low, close: c.close_price,
                    }));
                    this.candleSeries.setData(k);

                    const v = this.allCandles.map(c => ({
                        time: Math.floor(new Date(c.open_time).getTime() / 1000),
                        value: c.volume,
                        color: (c.close_price >= c.open_price) ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'
                    }));
                    this.volumeSeries.setData(v);
                    
                    this.chart.timeScale().fitContent();
                    setTimeout(() => { 
                        try { 
                            this.chart.timeScale().fitContent(); 
                        } catch(_){} 
                    }, 0);
                    
                    // Zoom-in to make candles visually larger (60% closer for easier interaction)
                    setTimeout(() => {
                        const range = this.chart.timeScale().getVisibleRange();
                        if (range) {
                            const pad = Math.floor((range.to - range.from) * 0.60);
                            this.chart.timeScale().setVisibleRange({ from: range.from + pad, to: range.to - pad });
                        }
                        this.redrawOverlay();
                    }, 100);
                    
                } catch (e) {
                    console.error(e);
                    alert('Не удалось загрузить исторические данные.');
                }
            }
			generateData(startDate = new Date('2018-01-01T00:00:00Z'), endDate = new Date()) {
				const out = [];
				let d = new Date(startDate);
				let price = 300;
				while (d <= endDate) {
					const vol = 10000 + Math.random()*50000;
					const volat = 0.025;
                    const open = price;
					const delta = (Math.random()-0.5)*volat;
					const close = open * (1 + delta);
					const high = Math.max(open, close) * (1 + Math.random()*volat*0.6);
					const low = Math.min(open, close) * (1 - Math.random()*volat*0.6);
					out.push({
						open_time: d.toISOString(),
						close_time: new Date(d.getTime()+24*60*60*1000-1).toISOString(),
						open_price: open.toFixed(2), close_price: close.toFixed(2),
						high: high.toFixed(2), low: low.toFixed(2), volume: vol.toFixed(2)
					});
					price = close;
					d.setUTCDate(d.getUTCDate()+1);
				}
				return out;
			}

			bindUI() {
				// Old toolbar buttons (if they exist)
				const analyzeBtn = document.getElementById('analyze-btn'); if (analyzeBtn) analyzeBtn.addEventListener('click', () => this.analyze());
				const clearBtn = document.getElementById('clear-btn'); if (clearBtn) clearBtn.addEventListener('click', () => this.showClearConfirmationModal());
				const resetBtn = document.getElementById('reset-view-btn'); if (resetBtn) resetBtn.addEventListener('click', () => this.resetView());
				const toggleVolumeBtn = document.getElementById('toggle-volume-btn'); if (toggleVolumeBtn) toggleVolumeBtn.addEventListener('click', () => this.toggleVolume());
				const toSelectedBtn = document.getElementById('to-selected-btn'); if (toSelectedBtn) toSelectedBtn.addEventListener('click', () => this.zoomToSelected());
				const prevMatchBtn = document.getElementById('prev-match-btn'); if (prevMatchBtn) prevMatchBtn.addEventListener('click', () => this.gotoMatch(-1));
				const nextMatchBtn = document.getElementById('next-match-btn'); if (nextMatchBtn) nextMatchBtn.addEventListener('click', () => this.gotoMatch(1));
				const symbolSelect = document.getElementById('symbol-select');
                    if (symbolSelect) {
                        symbolSelect.value = this.currentSymbol;
                        symbolSelect.addEventListener('change', (e) => {
                            this.switchSymbol(e.target.value);
                        });
                    }
                document.querySelectorAll('[data-tf]').forEach(b => b.addEventListener('click', (e) => {
					document.querySelectorAll('[data-tf]').forEach(x => x.classList.remove('active'));
                        e.target.classList.add('active');
					const newTF = e.target.getAttribute('data-tf');
					if (newTF !== this.currentTimeframe) {
						this.switchTimeframe(newTF);
					}
				}));

				// Mobile navigation buttons (reduced)
				const navVolume = document.getElementById('nav-volume'); if (navVolume) navVolume.addEventListener('click', () => this.toggleVolume());
				const navAnalysis = document.getElementById('nav-analysis'); if (navAnalysis) navAnalysis.addEventListener('click', () => this.analyze());
				const navClear = document.getElementById('nav-clear'); if (navClear) navClear.addEventListener('click', () => this.showClearConfirmationModal());
				
				// Chart controls overlay buttons
				const navPrev = document.getElementById('nav-prev'); if (navPrev) navPrev.addEventListener('click', () => this.gotoMatch(-1));
				const navNext = document.getElementById('nav-next'); if (navNext) navNext.addEventListener('click', () => this.gotoMatch(1));
				const navToSelected = document.getElementById('nav-to-selected'); if (navToSelected) navToSelected.addEventListener('click', () => this.zoomToSelected());
				const navVolumeOverlay = document.getElementById('nav-volume-overlay'); if (navVolumeOverlay) navVolumeOverlay.addEventListener('click', () => this.toggleVolume());
				const navPatterns = document.getElementById('nav-patterns'); if (navPatterns) navPatterns.addEventListener('click', () => this.showPatternsModal());
				const toggleControlsBtn = document.getElementById('toggle-controls-btn'); if (toggleControlsBtn) toggleControlsBtn.addEventListener('click', () => this.toggleChartControls());
				
				// Общий анализ паттернов
				const loadGeneralAnalysisBtn = document.getElementById('load-general-analysis');
				if (loadGeneralAnalysisBtn) {
					loadGeneralAnalysisBtn.addEventListener('click', () => this.loadGeneralAnalysis());
				}

				// Clear confirmation modal buttons
				document.getElementById('confirm-clear-btn').addEventListener('click', () => {
					// Сохраняем текущий таймфрейм перед перезагрузкой
					localStorage.setItem('savedTimeframe', this.currentTimeframe);
					window.location.reload();
				});
				document.getElementById('cancel-clear-btn').addEventListener('click', () => this.hideClearConfirmationModal());
				document.getElementById('close-clear-modal').addEventListener('click', () => this.hideClearConfirmationModal());

				// Modal close button
				document.querySelector('.close-modal').addEventListener('click', () => this.hidePatternsModal());
				
				// Close modal when clicking outside
				document.getElementById('patterns-modal').addEventListener('click', (e) => {
					if (e.target.id === 'patterns-modal') {
						this.hidePatternsModal();
					}
				});
				document.getElementById('clear-confirmation-modal').addEventListener('click', (e) => {
					if (e.target.id === 'clear-confirmation-modal') {
						this.hideClearConfirmationModal();
					}
				});
				
				// Устанавливаем активный таймфрейм в UI
				this.setActiveTimeframe();
            }

			onClick(param) {
                if (!param || !param.time) return;
				const ts = param.time;
				const idx = this.allCandles.findIndex(c => Math.floor(new Date(c.open_time).getTime()/1000) === ts);
				if (idx === -1) return;
				// Блокируем выбор свечей вне границ датасета
				const t = new Date(this.allCandles[idx].open_time);
				if (this.datasetStart && this.datasetEnd && (t < this.datasetStart || t > this.datasetEnd)) {
					this.toast('Свеча вне диапазона датасета');
                        return;
                    }
				if (this.selectedIndices.has(idx)) this.selectedIndices.delete(idx);
				else {
					if (this.selectedIndices.size >= 6) { alert('Можно выбрать максимум 6 свечей'); return; }
					this.selectedIndices.add(idx);
				}
				this.updateSelected();
			}

			updateSelected() {
				safeSetTextContent('selected-count', this.selectedIndices.size);
				const analyzeBtn = document.getElementById('analyze-btn'); 
				if (analyzeBtn) analyzeBtn.disabled = this.selectedIndices.size === 0;
				
				// Обновляем кнопку общего анализа
				const generalAnalysisBtn = document.getElementById('load-general-analysis');
				if (generalAnalysisBtn) generalAnalysisBtn.disabled = this.selectedIndices.size === 0;
				this.selectedMarkers.clear();
				this.selectedHighlightPoints = [];
				[...this.selectedIndices].forEach((i, index) => {
					const t = Math.floor(new Date(this.allCandles[i].open_time).getTime()/1000);
					// Более яркие и заметные маркеры для выбранных свечей
					this.selectedMarkers.set(i, { 
						time: t, 
						position: 'aboveBar', 
						color: '#ff6b35', 
						shape: 'circle', 
						text: `${index + 1}`, 
						size: 1.5,
						textColor: '#ffffff',
						backgroundColor: '#ff6b35'
					});
					this.selectedHighlightPoints.push({ time: t, color: '#ff6b35', index: index + 1 });
				});
				this.applyMarkers();
				this.redrawOverlay();
				
				// Показываем/скрываем индикатор выбранных свечей
				this.updateSelectedIndicator();
			}
			
			updateSelectedIndicator() {
				let indicator = document.querySelector('.selected-candles-indicator');
				if (this.selectedIndices.size > 0) {
					if (!indicator) {
						indicator = document.createElement('div');
						indicator.className = 'selected-candles-indicator';
						document.body.appendChild(indicator);
					}
					indicator.textContent = `Выбрано: ${this.selectedIndices.size} свечей`;
					indicator.style.display = 'block';
				} else if (indicator) {
					indicator.style.display = 'none';
				}
			}
			
			// Принудительное восстановление выделения выбранных свечей
			forceRestoreSelection() {
				if (this.selectedIndices && this.selectedIndices.size > 0) {
					this.updateSelected();
					setTimeout(() => {
						this.redrawOverlay();
						this.applyMarkers();
					}, 50);
				}
			}

			applyMarkers() {
				const sel = Array.from(this.selectedMarkers.values());
				const pats = Array.from(this.patternMarkers.values()).flat();
				this.candleSeries.setMarkers([...sel, ...pats]);
            }

            clearSelection() {
				this.selectedIndices.clear();
				this.selectedMarkers.clear();
				this.selectedHighlightPoints = [];
				this.applyMarkers();
				safeSetTextContent('selected-count', '0');
				const analyzeBtn = document.getElementById('analyze-btn');
				if (analyzeBtn) analyzeBtn.disabled = true;
				
				// Обновляем кнопку общего анализа
				const generalAnalysisBtn = document.getElementById('load-general-analysis');
				if (generalAnalysisBtn) generalAnalysisBtn.disabled = true;
				this.redrawOverlay();
				
				// Скрываем индикатор выбранных свечей
				this.updateSelectedIndicator();
			}

			resetView() {
                this.chart.timeScale().fitContent();
				// Apply zoom after reset
				setTimeout(() => {
					const range = this.chart.timeScale().getVisibleRange();
					if (range) {
						const pad = Math.floor((range.to - range.from) * 0.60);
						this.chart.timeScale().setVisibleRange({ from: range.from + pad, to: range.to - pad });
					}
				}, 50);
				this.patternMarkers.clear();
				this.applyMarkers();
				
				// ВАЖНО: Восстанавливаем выделение выбранных свечей после сброса
				if (this.selectedIndices && this.selectedIndices.size > 0) {
					this.updateSelected();
				}
				
				this.redrawOverlay();
            }

            toggleVolume() {
                this.volumeVisible = !this.volumeVisible;
                if (this.volumeVisible) {
					const v = this.allCandles.map(c => ({
						time: Math.floor(new Date(c.open_time).getTime() / 1000),
						value: +c.volume,
						color: (+c.close_price >= +c.open_price) ? 'rgba(34,197,94,0.25)' : 'rgba(239,68,68,0.25)'
					}));
					this.volumeSeries.setData(v);
                } else {
                    this.volumeSeries.setData([]);
				}
				
				// Обновляем текст кнопок
				const buttonText = this.volumeVisible ? 'Скрыть объем' : 'Показать объем';
				const iconClass = this.volumeVisible ? 'fas fa-chart-bar' : 'fas fa-chart-bar';
				
				// Обновляем кнопку в toolbar
				const toggleVolumeBtn = document.getElementById('toggle-volume-btn');
				if (toggleVolumeBtn) {
					toggleVolumeBtn.title = buttonText;
					toggleVolumeBtn.innerHTML = `<i class="${iconClass}"></i> ${this.volumeVisible ? 'Объем' : 'Объем'}`;
				}
				
				// Обновляем кнопку в мобильной навигации
				const navVolume = document.getElementById('nav-volume');
				if (navVolume) {
					navVolume.innerHTML = `<i class="${iconClass}"></i><span>${this.volumeVisible ? 'Объем' : 'Объем'}</span>`;
				}
				
				// Обновляем кнопку в chart controls overlay
				const navVolumeOverlay = document.getElementById('nav-volume-overlay');
				if (navVolumeOverlay) {
					navVolumeOverlay.innerHTML = `<i class="${iconClass}"></i><span>${this.volumeVisible ? 'Объем' : 'Объем'}</span>`;
				}
				
				this.toast(this.volumeVisible ? 'Объем показан' : 'Объем скрыт');
			}

            async analyze() {
                if (this.selectedIndices.size === 0) return;
                const order = [...this.selectedIndices].sort((a,b) => a-b);
                const candles = order.map(i => this.allCandles[i]);
                
                // Исправляем: отправляем точное количество выбранных свечей
                const payload = { 
                    num_candles: this.selectedIndices.size,
                    candles, 
                    timeframe: this.currentTimeframe,
                    symbol: this.currentSymbol,  // ← добавить эту строку
                    no_cache: true
                };
                
                // UI state
                const btn = document.getElementById('analyze-btn');
                const loader = this.ensureLoader();
                if (btn) btn.disabled = true; 
                loader.style.display = 'flex';
                
                try {
                    console.log('Отправляем запрос на анализ паттерна...');
                    // Создаем AbortController для таймаута
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 минуты таймаут
                    
                    const res = await fetch('/api/pattern/analyze', { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    console.log('Получен ответ:', res.status);
                    
                    if (!res.ok) {
                        if (res.status === 408) {
                            throw new Error('Превышено время ожидания. Попробуйте выбрать меньший период или повторите попытку.');
                        } else if (res.status === 500) {
                            throw new Error('Ошибка сервера. Попробуйте позже.');
                        } else {
                            throw new Error(`Ошибка сервера: ${res.status}`);
                        }
                    }
                    
                    const data = await res.json();
                    console.log('Данные анализа:', data);
                    
                    if (!data.success) {
                        throw new Error(data.message || 'Ошибка анализа');
                    }
                    
                    this.renderResults(data);
                    this.drawPatternMarkers(data.matched_patterns);
                    if (!data.matched_patterns || data.matched_patterns.length === 0) this.toast('Совпадения не найдены');
                    this.toast('Анализ завершён');
                    
                    // Show chart controls after analysis
                    const chartControls = document.getElementById('chart-controls');
                    if (chartControls) chartControls.classList.add('visible');
                    this.switchToAnalysisMode();
                } catch (e) {
                    if (e.name === 'AbortError') {
                        this.toast('Превышено время ожидания. Попробуйте выбрать меньший период.');
                    } else {
                        this.toast('Ошибка: ' + e.message);
                    }
                    console.error('Ошибка анализа:', e);
                } finally {
                    if (btn) btn.disabled = this.selectedIndices.size === 0;
                    loader.style.display = 'none';
                }
            }

			renderResults(result) {
                safeSetTextContent('matches-found', result.statistics.matches_found);
                safeSetTextContent('pattern-length', result.pattern_info.pattern_len);
                
				const percents = result.statistics.distribution_percents || {};
				const avg = Object.keys(percents).length ? (Object.values(percents).reduce((a,b)=>a+b,0) / Object.keys(percents).length) : 0;
				safeSetTextContent('accuracy', (avg||0).toFixed(2) + '%');

				const patternInfoHTML = `
					<div class="stat"><span>Начало</span><span class="val">${result.pattern_info.pattern_start}</span></div>
					<div class="stat"><span>Конец</span><span class="val">${result.pattern_info.pattern_end}</span></div>
					<div class="stat"><span>Свечей</span><span class="val">${result.pattern_info.pattern_len}</span></div>
				`;
				safeSetInnerHTML('pattern-info', patternInfoHTML);
				safeSetStyle('pattern-info-card', 'display', '');

				safeSetInnerHTML('matches', '');
				this.matchedRanges = [];
				(result.matched_patterns || []).forEach((pat, i) => {
					const first = pat[0];
					const last = pat[pat.length-1];
                    const change = result.price_changes ? result.price_changes[i] : 0;					
					this.matchedRanges.push([ Math.floor(new Date(first.date).getTime()/1000), Math.floor(new Date(last.date).getTime()/1000) ]);
					const el = document.createElement('div');
					el.className = 'match';
					el.setAttribute('data-pattern-index', i);
					el.innerHTML = `
						<div class="hdr">
							<div class="range">
								<span style="color: var(--accent); font-weight: 600;">Паттерн ${i + 1}</span>
								<br>
								<small style="color: var(--muted);">${new Date(first.date).toLocaleDateString()} — ${new Date(last.date).toLocaleDateString()}</small>
							</div>
							<div class="badge ${change>=0?'up':'down'}">${change>=0?'+':''}${change.toFixed(2)}%</div>
                    </div>
					`;
					el.addEventListener('click', () => {
						// Убираем активный класс с других элементов
						document.querySelectorAll('.match').forEach(m => m.classList.remove('active'));
						// Добавляем активный класс к текущему элементу
						el.classList.add('active');
						
						this.currentMatchIndex = i;
						this.updateMatchIndexLabel();
						const [from, to] = this.matchedRanges[i];
						this.zoomTo(from, to);
					});
					matches.appendChild(el);
				});
				this.currentMatchIndex = this.matchedRanges.length ? 0 : -1;
				this.updateMatchIndexLabel();
			}

			drawPatternMarkers(matched) {
				this.patternMarkers.clear();
				// Более яркие и контрастные цвета для паттернов
				const colors = ['#00d4aa', '#ff4757', '#3742fa', '#ffa502', '#2ed573', '#ff3838'];
				this.matchedHighlightPoints = [];
				(matched || []).forEach((pat, pIdx) => {
					const col = colors[pIdx % colors.length];
					const arr = [];
					for (let i=0;i<pat.length;i++) {
						const t = Math.floor(new Date(pat[i].date).getTime()/1000);
						// Более заметные маркеры для паттернов
						arr.push({ 
							time: t, 
							position: 'belowBar', 
							color: col, 
							shape: 'square', 
							text: `${pIdx+1}`, 
							size: 1.8,
							textColor: '#ffffff',
							backgroundColor: col
						});
						this.matchedHighlightPoints.push({ time: t, color: col, patternIndex: pIdx + 1 });
					}
					this.patternMarkers.set(pIdx, arr);
				});
				this.applyMarkers();
				this.redrawOverlay();
				if (matched && matched.length && matched[0].length) {
					const f = matched[0][0];
					const l = matched[0][matched[0].length-1];
					this.zoomTo(Math.floor(new Date(f.date).getTime()/1000), Math.floor(new Date(l.date).getTime()/1000));
				}
			}

			zoomTo(from, to) {
				const pad = Math.max(3*24*60*60, Math.floor((to-from)*0.5));
				this.chart.timeScale().setVisibleRange({ from: from - pad, to: to + pad });
				
				// Принудительно обновляем оверлей после изменения видимого диапазона
				setTimeout(() => {
					this.redrawOverlay();
				}, 50);
			}

			// ===== Overlay helpers for highlighting candles =====
			ensureOverlay() {
				if (this.overlay) return this.overlay;
				const host = document.getElementById('chart');
				const canvas = document.createElement('canvas');
				canvas.style.position = 'absolute';
				canvas.style.left = '0';
				canvas.style.top = '0';
				canvas.style.pointerEvents = 'none';
				canvas.width = host.clientWidth; canvas.height = host.clientHeight;
				host.appendChild(canvas);
				this.overlay = canvas;
				return canvas;
			}

			resizeOverlay() {
				const host = document.getElementById('chart');
				if (!this.overlay) return;
				this.overlay.width = host.clientWidth;
				this.overlay.height = host.clientHeight;
			}

			redrawOverlay() {
				this.ensureOverlay();
				if (!this.overlay) return;
				
				const ctx = this.overlay.getContext('2d');
				ctx.clearRect(0,0,this.overlay.width,this.overlay.height);
				
				const ts = this.chart.timeScale();
				const barW = ts.getBarSpacing ? ts.getBarSpacing() : 12;
				const h = this.overlay.height;
				
				// Проверяем, что у нас есть выбранные свечи для отображения
				if (!this.selectedHighlightPoints || this.selectedHighlightPoints.length === 0) {
					// Если нет выбранных свечей, но есть индексы, восстанавливаем их
					if (this.selectedIndices && this.selectedIndices.size > 0) {
						this.updateSelected();
					}
				}
				
				// Рисуем найденные паттерны сначала (более заметные)
				for (const p of (this.matchedHighlightPoints || [])) {
					const x = ts.timeToCoordinate(p.time);
					if (x === null || x === undefined) continue;
					
					// Создаем градиент для паттернов
					const gradient = ctx.createLinearGradient(x - barW*0.8, 0, x + barW*0.8, 0);
					gradient.addColorStop(0, this.hexToRgba(p.color, 0.0));
					gradient.addColorStop(0.5, this.hexToRgba(p.color, 0.25));
					gradient.addColorStop(1, this.hexToRgba(p.color, 0.0));
					
					ctx.fillStyle = gradient;
					ctx.fillRect(Math.round(x - barW*0.8), 0, Math.round(barW*1.6), h);
					
					// Более яркая граница для паттернов
					ctx.strokeStyle = this.hexToRgba(p.color, 0.8);
					ctx.lineWidth = 2;
					ctx.strokeRect(Math.round(x - barW*0.8)+1, 1, Math.round(barW*1.6)-2, h-2);
					
					// Добавляем пульсирующий эффект
					const time = Date.now() / 1000;
					const pulse = Math.sin(time * 3) * 0.1 + 0.9;
					ctx.fillStyle = this.hexToRgba(p.color, 0.15 * pulse);
					ctx.fillRect(Math.round(x - barW*0.6), 0, Math.round(barW*1.2), h);
				}
				
				// Рисуем выбранные свечи (еще более заметные)
				for (const p of (this.selectedHighlightPoints || [])) {
					const x = ts.timeToCoordinate(p.time);
					if (x === null || x === undefined) continue;
					
					// Создаем градиент для выбранных свечей
					const gradient = ctx.createLinearGradient(x - barW*0.7, 0, x + barW*0.7, 0);
					gradient.addColorStop(0, 'rgba(255,107,53,0.0)');
					gradient.addColorStop(0.5, 'rgba(255,107,53,0.4)');
					gradient.addColorStop(1, 'rgba(255,107,53,0.0)');
					
					ctx.fillStyle = gradient;
					ctx.fillRect(Math.round(x - barW*0.7), 0, Math.round(barW*1.4), h);
					
					// Очень яркая граница для выбранных свечей
					ctx.strokeStyle = 'rgba(255,107,53,1.0)';
					ctx.lineWidth = 3;
					ctx.strokeRect(Math.round(x - barW*0.7)+1.5, 1.5, Math.round(barW*1.4)-3, h-3);
					
					// Пульсирующий эффект для выбранных свечей
					const time = Date.now() / 1000;
					const pulse = Math.sin(time * 4) * 0.2 + 0.8;
					ctx.fillStyle = `rgba(255,107,53,${0.3 * pulse})`;
					ctx.fillRect(Math.round(x - barW*0.5), 0, Math.round(barW*1.0), h);
				}
			}

			hexToRgba(hex, a) {
				// supports #rrggbb format
				const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				if (!m) return `rgba(255,255,255,${a})`;
				const r = parseInt(m[1], 16), g = parseInt(m[2], 16), b = parseInt(m[3], 16);
				return `rgba(${r},${g},${b},${a})`;
			}

			startAnimation() {
				const animate = () => {
					this.redrawOverlay();
					this.animationFrame = requestAnimationFrame(animate);
				};
				animate();
			}

			stopAnimation() {
				if (this.animationFrame) {
					cancelAnimationFrame(this.animationFrame);
					this.animationFrame = null;
				}
			}

			ensureLoader() {
				let el = document.querySelector('.loading');
				if (!el) {
					el = document.createElement('div'); el.className = 'loading';
					const sp = document.createElement('div'); sp.className = 'spinner'; el.appendChild(sp);
					document.body.appendChild(el);
				}
				return el;
			}

			toast(msg) {
				if (!this.toastEl) { this.toastEl = document.createElement('div'); this.toastEl.className = 'toast'; document.body.appendChild(this.toastEl); }
				this.toastEl.textContent = msg; this.toastEl.style.display = 'block';
				clearTimeout(this.toastTimer); this.toastTimer = setTimeout(() => { this.toastEl.style.display = 'none'; }, 2200);
			}

			// ===== Navigation helpers =====
			zoomToSelected() {
				if (!this.selectedIndices.size) { this.toast('Сначала выберите свечи'); return; }
				
				// Принудительно восстанавливаем выделение ПЕРЕД зумом
				this.updateSelected();
				this.applyMarkers();
				this.redrawOverlay();
				
				const sorted = [...this.selectedIndices].sort((a,b)=>a-b);
				const first = Math.floor(new Date(this.allCandles[sorted[0]].open_time).getTime()/1000);
				const last = Math.floor(new Date(this.allCandles[sorted[sorted.length-1]].open_time).getTime()/1000);
				
				this.zoomTo(first, last);
				
				// Множественные обновления для гарантии
				setTimeout(() => {
					this.updateSelected();
					this.applyMarkers();
					this.redrawOverlay();
				}, 100);
				
				setTimeout(() => {
					this.updateSelected();
					this.applyMarkers();
					this.redrawOverlay();
				}, 300);
			}

			gotoMatch(step) {
				if (!this.matchedRanges.length) { this.toast('Совпадений нет'); return; }
				if (this.currentMatchIndex === -1) this.currentMatchIndex = 0;
				else this.currentMatchIndex = (this.currentMatchIndex + step + this.matchedRanges.length) % this.matchedRanges.length;
				this.updateMatchIndexLabel();
				
				// Обновляем активное состояние в списке
				document.querySelectorAll('.match').forEach(m => m.classList.remove('active'));
				const activeMatch = document.querySelector(`[data-pattern-index="${this.currentMatchIndex}"]`);
				if (activeMatch) activeMatch.classList.add('active');
				
				const [from, to] = this.matchedRanges[this.currentMatchIndex];
				this.zoomTo(from, to);
				
				// Принудительно обновляем оверлей после навигации
				setTimeout(() => {
					this.redrawOverlay();
					this.applyMarkers();
				}, 100);
			}

			updateMatchIndexLabel() {
				const label = this.matchedRanges.length ? `${this.currentMatchIndex+1}/${this.matchedRanges.length}` : '0/0';
				safeSetTextContent('match-index', label);
			}

			showPatternsModal() {
				const modal = document.getElementById('patterns-modal');
				const patternsList = document.getElementById('modal-patterns-list');
				const patternStats = document.getElementById('modal-pattern-stats');
				
				// Clear previous content
				patternsList.innerHTML = '';
				patternStats.innerHTML = '';
				
				// Add pattern statistics
				if (this.matchedRanges && this.matchedRanges.length > 0) {
					const selectedCount = this.selectedIndices.size;
					const patternLength = selectedCount;
					const matchesFound = this.matchedRanges.length;
					
					patternStats.innerHTML = `
						<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px;">
							<div class="stat">
								<span style="color: var(--muted); font-size: 12px;">Выбрано свечей</span>
								<span class="val" style="color: var(--accent); font-weight: 600;">${selectedCount}</span>
							</div>
							<div class="stat">
								<span style="color: var(--muted); font-size: 12px;">Найдено совпадений</span>
								<span class="val" style="color: var(--green); font-weight: 600;">${matchesFound}</span>
							</div>
						</div>
						<div style="font-size: 11px; color: var(--muted); text-align: center;">
							Кликните на паттерн для перехода к нему на графике
						</div>
					`;
					
					// Add patterns
					this.matchedRanges.forEach((range, index) => {
						const startDate = new Date(range[0] * 1000).toLocaleDateString();
						const endDate = new Date(range[1] * 1000).toLocaleDateString();
						
						const patternEl = document.createElement('div');
						patternEl.className = 'match';
						patternEl.innerHTML = `
							<div class="hdr">
								<div class="range">Паттерн ${index + 1}</div>
								<div class="badge up">${index + 1}</div>
							</div>
							<div style="font-size: 11px; color: var(--muted); margin-top: 4px;">
								${startDate} — ${endDate}
							</div>
						`;
						patternEl.addEventListener('click', () => {
							this.currentMatchIndex = index;
							this.updateMatchIndexLabel();
							this.zoomTo(range[0], range[1]);
							this.hidePatternsModal();
						});
						patternsList.appendChild(patternEl);
					});
				} else {
					patternStats.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">Сначала выберите свечи и запустите анализ</div>';
					patternsList.innerHTML = '';
				}
				
				modal.style.display = 'block';
			}

			hidePatternsModal() {
				const modal = document.getElementById('patterns-modal');
				modal.style.display = 'none';
			}

			showClearConfirmationModal() {

                localStorage.setItem('savedSymbol', this.currentSymbol);
                
                const modal = document.getElementById('clear-confirmation-modal');
				
				// Update statistics in modal
				safeSetTextContent('selected-count-modal', this.selectedIndices.size);
				safeSetTextContent('patterns-count-modal', this.matchedRanges.length);
				
				if (modal) modal.style.display = 'block';
			}

			hideClearConfirmationModal() {
				const modal = document.getElementById('clear-confirmation-modal');
				modal.style.display = 'none';
			}

			toggleChartControls() {
				const chartControls = document.getElementById('chart-controls');
				const toggleBtn = document.getElementById('toggle-controls-btn');
				const toggleIcon = toggleBtn.querySelector('i');
				
				if (chartControls.classList.contains('collapsed')) {
					chartControls.classList.remove('collapsed');
					toggleIcon.className = 'fas fa-chevron-down';
				} else {
					chartControls.classList.add('collapsed');
					toggleIcon.className = 'fas fa-chevron-up';
				}
			}

			async switchTimeframe(newTimeframe) {
				// Сохраняем новый таймфрейм
				this.currentTimeframe = newTimeframe;
				
				// Очищаем только паттерны, но сохраняем выбранные свечи если они есть
				const hadSelection = this.selectedIndices.size > 0;
				this.patternMarkers.clear();
				this.matchedHighlightPoints = [];
				this.matchedRanges = [];
				this.currentMatchIndex = -1;
				
				// Очищаем выбранные свечи только если их не было
				if (!hadSelection) {
					this.selectedIndices.clear();
					this.selectedMarkers.clear();
					this.selectedHighlightPoints = [];
				}
				
				// Показываем загрузку
				const loader = this.ensureLoader();
				loader.style.display = 'flex';
				
				try {
					// Перезагружаем данные с новым таймфреймом
					await this.loadData();
					
					// Обновляем UI
					safeSetTextContent('matches-found', '0');
					safeSetTextContent('pattern-length', '0');
					safeSetTextContent('accuracy', '0%');
					safeSetStyle('pattern-info-card', 'display', 'none');
					safeSetInnerHTML('matches', '');
					
					// Восстанавливаем выделение выбранных свечей если они были
					if (hadSelection) {
						this.updateSelected();
					}
					
					// Обновляем отображение таймфрейма в header
					const timeframeMap = {
						'1h': '1ч',
						'4h': '4ч',
						'1d': '1Д',
						'1w': '1Н'
					};
					const kpiTF = document.querySelector('.kpi strong');
					if (kpiTF) kpiTF.textContent = timeframeMap[newTimeframe] || newTimeframe;
					
					this.toast(`Загружены данные для таймфрейма ${timeframeMap[newTimeframe] || newTimeframe}`);
				} catch (e) {
					this.toast('Ошибка загрузки данных: ' + e.message);
				} finally {
					loader.style.display = 'none';
				}
			}

			switchToAnalysisMode() {
				// Переключаем в режим анализа с высокой чувствительностью
				this.isAnalysisMode = true;
				// Уменьшаем minBarSpacing для более свободного масштабирования
				this.chart.applyOptions({
					timeScale: {
						minBarSpacing: 2 // Минимальное расстояние для режима анализа (можно увеличивать в 7.5 раз сильнее)
					}
				});
				
				// ВАЖНО: Сохраняем выделение выбранных свечей в режиме анализа
				this.updateSelected();
			}

			switchToSelectionMode() {
				// Возвращаем в режим выбора свечей со средней чувствительностью
				this.isAnalysisMode = false;
				// Увеличиваем minBarSpacing для ограниченного масштабирования
				this.chart.applyOptions({
					timeScale: {
						minBarSpacing: 15, // Среднее расстояние для режима выбора
						barSpacing: 60 // Возвращаем приближение
					}
				});
				this.chart.timeScale().fitContent(); // Подгоняем график
			}

			setActiveTimeframe() {
				// Устанавливаем активный таймфрейм в UI
				document.querySelectorAll('[data-tf]').forEach(btn => {
					btn.classList.remove('active');
					if (btn.getAttribute('data-tf') === this.currentTimeframe) {
						btn.classList.add('active');
					}
				});
				
				// Обновляем отображение таймфрейма в header
				const timeframeMap = {
					'1h': '1ч',
					'4h': '4ч',
					'1d': '1Д',
					'1w': '1Н'
				};
				const kpiTF = document.querySelector('.kpi strong');
				if (kpiTF) kpiTF.textContent = timeframeMap[this.currentTimeframe] || this.currentTimeframe;
			}

			// ===== Общий анализ паттернов =====
			async loadGeneralAnalysis() {
				const btn = document.getElementById('load-general-analysis');
				if (btn) btn.disabled = true;
				
				// Показываем загрузку
				this.showGeneralAnalysisLoading();
				
				try {
					// Проверяем, что данные загружены
					if (!this.allCandles || this.allCandles.length === 0) {
						throw new Error('Данные графика не загружены');
					}
					
					console.log('Загружаем общий анализ через /analyze_pattern...');
					
					// Проверяем, есть ли выбранные свечи для анализа
					if (this.selectedIndices.size === 0) {
						throw new Error('Сначала выберите свечи для анализа');
					}
					
					// Берем выбранные свечи для анализа
					const order = [...this.selectedIndices].sort((a,b) => a-b);
					const selectedCandles = order.map(i => this.allCandles[i]);
					
					const payload = {
						num_candles: selectedCandles.length,
						candles: selectedCandles.map(candle => ({
							open_time: candle.open_time,
							close_time: candle.close_time,
							open_price: candle.open_price,
							close_price: candle.close_price,
							high: candle.high,
							low: candle.low,
							volume: candle.volume
						})),
						timeframe: this.currentTimeframe,
						no_cache: true  // Отключаем кэширование для общего анализа
					};
					
					console.log('Отправляем запрос:', payload);
					
					const response = await fetch('/api/pattern/analyze', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(payload)
					});
					
					console.log('Response status:', response.status);
					
					if (!response.ok) {
						if (response.status === 408) {
							throw new Error('Превышено время ожидания анализа. Попробуйте позже.');
						} else if (response.status === 500) {
							throw new Error('Ошибка сервера при анализе. Попробуйте позже.');
						} else {
							throw new Error(`Ошибка сервера: ${response.status}`);
						}
					}
					
					const data = await response.json();
					console.log('Response data:', data);
					
					if (!data.success) {
						throw new Error(data.message || 'Ошибка загрузки анализа');
					}
					
									// Отображаем простую статистику из результата
				this.displaySimpleAnalysis(data);
				this.toast('Анализ выбранных свечей завершен');
				
				} catch (error) {
					console.error('Ошибка загрузки общего анализа:', error);
					this.toast('Ошибка: ' + error.message);
					// Скрываем загрузку при ошибке
					this.hideGeneralAnalysisLoading();
				} finally {
					if (btn) btn.disabled = false;
				}
			}

			createGeneralAnalysisData(analysisResult) {
				// Создаем общую статистику из результата анализа паттернов
				const totalCandles = this.allCandles.length;
				const firstDate = this.allCandles[0] ? new Date(this.allCandles[0].open_time).toISOString().slice(0, 10) : 'N/A';
				const lastDate = this.allCandles[totalCandles-1] ? new Date(this.allCandles[totalCandles-1].open_time).toISOString().slice(0, 10) : 'N/A';
				
				// Вычисляем статистику рынка
				const volumes = this.allCandles.map(c => parseFloat(c.volume));
				const prices = this.allCandles.map(c => parseFloat(c.close_price));
				const highs = this.allCandles.map(c => parseFloat(c.high));
				const lows = this.allCandles.map(c => parseFloat(c.low));
				
				// Вычисляем волатильность
				const returns = [];
				for (let i = 1; i < prices.length; i++) {
					returns.push((prices[i] - prices[i-1]) / prices[i-1]);
				}
				const volatility = returns.length > 0 ? Math.sqrt(returns.reduce((sum, r) => sum + r*r, 0) / returns.length) * 100 : 0;
				
				// Анализируем направление паттернов из найденных совпадений
				const matchedPatterns = analysisResult.matched_patterns || [];
				let bullishCount = 0;
				let bearishCount = 0;
				
				matchedPatterns.forEach(pattern => {
					if (pattern.length > 0) {
						const firstCandle = pattern[0];
						const lastCandle = pattern[pattern.length - 1];
						const priceChange = (lastCandle.close - firstCandle.open) / firstCandle.open;
						if (priceChange > 0) {
							bullishCount++;
						} else {
							bearishCount++;
						}
					}
				});
				
				// Создаем недавние паттерны из найденных совпадений
				const recentPatterns = matchedPatterns.slice(-10).map((pattern, index) => {
					if (pattern.length === 0) return null;
					
					const firstCandle = pattern[0];
					const lastCandle = pattern[pattern.length - 1];
					const priceChange = (lastCandle.close - firstCandle.open) / firstCandle.open * 100;
					const volumeChange = (lastCandle.volume - firstCandle.volume) / firstCandle.volume * 100;
					
					return {
						start_date: firstCandle.date.slice(0, 10),
						end_date: lastCandle.date.slice(0, 10),
						price_change: priceChange,
						volume_change: volumeChange,
						direction: priceChange >= 0 ? 'bullish' : 'bearish',
						strength: Math.abs(priceChange),
						candles: pattern
					};
				}).filter(p => p !== null);
				
				return {
					success: true,
					timeframe: this.currentTimeframe,
					total_candles: totalCandles,
					date_range: {
						start: firstDate,
						end: lastDate
					},
					market_statistics: {
						total_volume: volumes.reduce((sum, v) => sum + v, 0),
						avg_volume: volumes.reduce((sum, v) => sum + v, 0) / volumes.length,
						price_range: {
							min: Math.min(...lows),
							max: Math.max(...highs),
							current: prices[prices.length - 1]
						},
						volatility: volatility
					},
					pattern_statistics: {
						bullish_patterns: bullishCount,
						bearish_patterns: bearishCount,
						avg_body_size: 0, // Можно вычислить если нужно
						avg_volume_ratio: 0 // Можно вычислить если нужно
					},
					recent_patterns: recentPatterns
				};
			}

			displaySimpleAnalysis(data) {
				// Скрываем загрузку при отображении результатов
				this.hideGeneralAnalysisLoading();
				
				// Отображаем данные напрямую из performance_stats и statistics
				console.log('Отображаем данные:', data);
				console.log('performance_stats:', data.performance_stats);
				console.log('statistics:', data.statistics);
				
				// Общая информация
				safeSetTextContent('total-candles', this.allCandles.length.toLocaleString());
				
				// Период данных
				const firstDate = new Date(this.allCandles[0].open_time).toLocaleDateString();
				const lastDate = new Date(this.allCandles[this.allCandles.length-1].open_time).toLocaleDateString();
				safeSetTextContent('data-period', `${firstDate} — ${lastDate}`);
				
				// Простая волатильность из данных
				const prices = this.allCandles.map(c => parseFloat(c.close_price));
				const returns = [];
				for (let i = 1; i < prices.length; i++) {
					returns.push((prices[i] - prices[i-1]) / prices[i-1]);
				}
				const volatility = returns.length > 0 ? Math.sqrt(returns.reduce((sum, r) => sum + r*r, 0) / returns.length) * 100 : 0;
				safeSetTextContent('volatility', volatility.toFixed(2) + '%');
				
				// Средний объем
				const volumes = this.allCandles.map(c => parseFloat(c.volume));
				const avgVolume = volumes.reduce((sum, v) => sum + v, 0) / volumes.length;
				safeSetTextContent('avg-volume', this.formatVolume(avgVolume));
				
				// Используем данные из performance_stats
				const perfStats = data.performance_stats || {};
				const bullishPercentage = perfStats.bullish_percentage || 0;
				const bearishPercentage = perfStats.bearish_percentage || 0;
				
				// Обновляем прогресс-бары с реальными данными
				const bullishCountValue = Math.round(bullishPercentage * (perfStats.total_patterns || 0) / 100);
				const bearishCountValue = Math.round(bearishPercentage * (perfStats.total_patterns || 0) / 100);
				
				safeSetTextContent('bullish-count', bullishCountValue);
				safeSetTextContent('bearish-count', bearishCountValue);
				
				// Анимируем прогресс-бары
				setTimeout(() => {
					const bullishBar = document.getElementById('bullish-bar');
					const bearishBar = document.getElementById('bearish-bar');
					
					if (bullishBar) bullishBar.style.width = bullishPercentage + '%';
					if (bearishBar) bearishBar.style.width = bearishPercentage + '%';
				}, 100);
				
				// Отображаем дополнительную статистику в карточке
				this.displayPerformanceStats(perfStats, data.statistics);
				
				// Отображаем найденные паттерны
				const matchedPatterns = data.matched_patterns || [];
				this.displayRecentPatterns(matchedPatterns.slice(-5));
				
				// Создаем мини-график
				this.createMiniChart(data);
			}

			displayPerformanceStats(perfStats, statistics) {
				// Создаем дополнительную карточку с детальной статистикой
				console.log('displayPerformanceStats вызвана с данными:', perfStats);
				let performanceCard = document.getElementById('performance-stats-card');
				if (!performanceCard) {
					// Создаем карточку если её нет
					const sidePanel = document.getElementById('side-panel');
					const generalCard = document.getElementById('general-analysis-card');
					
					performanceCard = document.createElement('div');
					performanceCard.id = 'performance-stats-card';
					performanceCard.className = 'card';
					performanceCard.innerHTML = `
						<h3>Статистика производительности</h3>
						<div class="performance-stats" id="performance-stats-content"></div>
					`;
					
					// Вставляем после карточки общего анализа
					generalCard.parentNode.insertBefore(performanceCard, generalCard.nextSibling);
				}
				
				const content = document.getElementById('performance-stats-content');
				content.innerHTML = `
					<div class="stat-list">
						<div class="stat">
							<span>Найдено паттернов</span>
							<span class="val" style="color: var(--accent);">${perfStats.total_patterns || 0}</span>
						</div>
						<div class="stat">
							<span>Успешность</span>
							<span class="val" style="color: var(--green);">${perfStats.success_rate || 0}%</span>
						</div>
						<div class="stat">
							<span>Медианное изменение</span>
							<span class="val" style="color: ${(perfStats.median_change || 0) >= 0 ? 'var(--green)' : 'var(--red)'}">
								${(perfStats.median_change || 0) >= 0 ? '+' : ''}${(perfStats.median_change || 0).toFixed(2)}%
							</span>
						</div>
						<div class="stat">
							<span>Лучшие 20%</span>
							<span class="val" style="color: var(--green);">+${(perfStats.top_20_percent_median || 0).toFixed(2)}%</span>
						</div>
						<div class="stat">
							<span>Худшие 20%</span>
							<span class="val" style="color: var(--red);">${(perfStats.bottom_20_percent_median || 0).toFixed(2)}%</span>
						</div>
					</div>
					<div class="performance-summary">
						<div class="summary-item">
							<span class="summary-label">Бычьи паттерны:</span>
							<span class="summary-value bullish">${perfStats.bullish_percentage || 0}%</span>
						</div>
						<div class="summary-item">
							<span class="summary-label">Медвежьи паттерны:</span>
							<span class="summary-value bearish">${perfStats.bearish_percentage || 0}%</span>
						</div>
					</div>
				`;
				
				performanceCard.style.display = 'block';
			}

			showGeneralAnalysisLoading() {
				const generalStats = document.getElementById('general-stats');
				if (generalStats) {
					generalStats.innerHTML = `
						<div class="general-analysis-loading">
							<i class="fas fa-spinner"></i>
							<span>Загрузка анализа...</span>
						</div>
					`;
					
					// Автоматически скрываем загрузку через 10 секунд
					setTimeout(() => {
						this.hideGeneralAnalysisLoading();
					}, 10000);
				}
			}

			hideGeneralAnalysisLoading() {
				const generalStats = document.getElementById('general-stats');
				if (generalStats) {
					const loading = generalStats.querySelector('.general-analysis-loading');
					if (loading) {
						loading.remove();
					}
				}
			}

			displayGeneralAnalysis(data) {
				// Обновляем основную статистику
				const totalCandles = document.getElementById('total-candles');
				if (totalCandles) totalCandles.textContent = data.total_candles.toLocaleString();
				
				const dataPeriod = document.getElementById('data-period');
				if (dataPeriod) dataPeriod.textContent = `${data.date_range.start} — ${data.date_range.end}`;
				
				const volatility = document.getElementById('volatility');
				if (volatility) volatility.textContent = data.market_statistics.volatility.toFixed(2) + '%';
				
				const avgVolume = document.getElementById('avg-volume');
				if (avgVolume) avgVolume.textContent = this.formatVolume(data.market_statistics.avg_volume);
				
				// Обновляем распределение паттернов
				const bullishCount = data.pattern_statistics.bullish_patterns;
				const bearishCount = data.pattern_statistics.bearish_patterns;
				const total = bullishCount + bearishCount;
				
				const bullishCountEl = document.getElementById('bullish-count');
				if (bullishCountEl) bullishCountEl.textContent = bullishCount.toLocaleString();
				
				const bearishCountEl = document.getElementById('bearish-count');
				if (bearishCountEl) bearishCountEl.textContent = bearishCount.toLocaleString();
				
				// Анимируем прогресс-бары
				setTimeout(() => {
					const bullishBar = document.getElementById('bullish-bar');
					const bearishBar = document.getElementById('bearish-bar');
					
					if (total > 0) {
						const bullishPercent = (bullishCount / total) * 100;
						const bearishPercent = (bearishCount / total) * 100;
						
						if (bullishBar) bullishBar.style.width = bullishPercent + '%';
						if (bearishBar) bearishBar.style.width = bearishPercent + '%';
					}
				}, 100);
				
				// Отображаем недавние паттерны
				this.displayRecentPatterns(data.recent_patterns);
				
				// Создаем мини-график
				this.createMiniChart(data);
			}

			displayRecentPatterns(patterns) {
				const recentPatternsCard = document.getElementById('recent-patterns-card');
				const recentPatternsList = document.getElementById('recent-patterns-list');
				
				if (!patterns || patterns.length === 0) {
					recentPatternsCard.style.display = 'none';
					return;
				}
				
				recentPatternsList.innerHTML = '';
				
				patterns.forEach((pattern, index) => {
					const patternEl = document.createElement('div');
					patternEl.className = 'recent-pattern';
					
					const priceChangeClass = pattern.price_change >= 0 ? 'positive' : 'negative';
					const volumeChangeClass = pattern.volume_change >= 0 ? 'positive' : 'negative';
					
					patternEl.innerHTML = `
						<div class="recent-pattern-header">
							<div class="recent-pattern-dates">
								${new Date(pattern.start_date).toLocaleDateString()} — ${new Date(pattern.end_date).toLocaleDateString()}
							</div>
							<div class="recent-pattern-direction ${pattern.direction}">
								${pattern.direction === 'bullish' ? '↗' : '↘'} ${pattern.direction}
							</div>
						</div>
						<div class="recent-pattern-stats">
							<div class="recent-pattern-stat">
								<span class="recent-pattern-stat-label">Изменение цены:</span>
								<span class="recent-pattern-stat-value ${priceChangeClass}">
									${pattern.price_change >= 0 ? '+' : ''}${pattern.price_change.toFixed(2)}%
								</span>
							</div>
							<div class="recent-pattern-stat">
								<span class="recent-pattern-stat-label">Изменение объема:</span>
								<span class="recent-pattern-stat-value ${volumeChangeClass}">
									${pattern.volume_change >= 0 ? '+' : ''}${pattern.volume_change.toFixed(1)}%
								</span>
							</div>
						</div>
					`;
					
					// Добавляем обработчик клика для перехода к паттерну на графике
					patternEl.addEventListener('click', () => {
						this.zoomToPattern(pattern);
					});
					
					recentPatternsList.appendChild(patternEl);
				});
				
				recentPatternsCard.style.display = 'block';
			}

			zoomToPattern(pattern) {
				if (!pattern.candles || pattern.candles.length === 0) return;
				
				const firstCandle = pattern.candles[0];
				const lastCandle = pattern.candles[pattern.candles.length - 1];
				
				const startTime = Math.floor(new Date(firstCandle.date).getTime() / 1000);
				const endTime = Math.floor(new Date(lastCandle.date).getTime() / 1000);
				
				this.zoomTo(startTime, endTime);
				this.toast(`Переход к паттерну ${pattern.direction}`);
			}

			formatVolume(volume) {
				if (volume >= 1e9) return (volume / 1e9).toFixed(1) + 'B';
				if (volume >= 1e6) return (volume / 1e6).toFixed(1) + 'M';
				if (volume >= 1e3) return (volume / 1e3).toFixed(1) + 'K';
				return volume.toFixed(0);
			}

			async createMiniChart(data) {
				const miniChartContainer = document.getElementById('mini-chart-container');
				const canvas = document.getElementById('mini-chart');
				
				if (!canvas || !miniChartContainer) return;
				
				// Показываем контейнер
				miniChartContainer.style.display = 'block';
				
				try {
					// Получаем последние 30 дней данных для мини-графика
					const response = await fetch(`/api/pattern/ohlcv?source=binance&timeframe=${this.currentTimeframe}&from=${this.getDateDaysAgo(30)}`);
					const chartData = await response.json();
					
					if (!chartData.success || !chartData.candles) return;
					
					// Создаем график
					const ctx = canvas.getContext('2d');
					const width = canvas.width;
					const height = canvas.height;
					
					// Очищаем canvas
					ctx.clearRect(0, 0, width, height);
					
					// Подготавливаем данные
					const prices = chartData.candles.slice(-30).map(c => parseFloat(c.close_price));
					const minPrice = Math.min(...prices);
					const maxPrice = Math.max(...prices);
					const priceRange = maxPrice - minPrice;
					
					// Настройки графика
					const padding = 10;
					const chartWidth = width - padding * 2;
					const chartHeight = height - padding * 2;
					
					// Рисуем фон
					ctx.fillStyle = '#0a0f14';
					ctx.fillRect(0, 0, width, height);
					
					// Рисуем сетку
					ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
					ctx.lineWidth = 1;
					for (let i = 0; i <= 4; i++) {
						const y = padding + (chartHeight / 4) * i;
						ctx.beginPath();
						ctx.moveTo(padding, y);
						ctx.lineTo(width - padding, y);
						ctx.stroke();
					}
					
					// Рисуем линию цены
					ctx.strokeStyle = '#f7931a';
					ctx.lineWidth = 2;
					ctx.beginPath();
					
					prices.forEach((price, index) => {
						const x = padding + (chartWidth / (prices.length - 1)) * index;
						const y = padding + chartHeight - ((price - minPrice) / priceRange) * chartHeight;
						
						if (index === 0) {
							ctx.moveTo(x, y);
						} else {
							ctx.lineTo(x, y);
						}
					});
					
					ctx.stroke();
					
					// Добавляем градиент под линией
					const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
					gradient.addColorStop(0, 'rgba(247, 147, 26, 0.3)');
					gradient.addColorStop(1, 'rgba(247, 147, 26, 0.05)');
					
					ctx.fillStyle = gradient;
					ctx.lineTo(width - padding, height - padding);
					ctx.lineTo(padding, height - padding);
					ctx.closePath();
					ctx.fill();
					
					// Добавляем точки на концах
					const firstPrice = prices[0];
					const lastPrice = prices[prices.length - 1];
					
					ctx.fillStyle = '#f7931a';
					ctx.beginPath();
					ctx.arc(padding, padding + chartHeight - ((firstPrice - minPrice) / priceRange) * chartHeight, 3, 0, 2 * Math.PI);
					ctx.fill();
					
					ctx.fillStyle = lastPrice >= firstPrice ? '#22c55e' : '#ef4444';
					ctx.beginPath();
					ctx.arc(width - padding, padding + chartHeight - ((lastPrice - minPrice) / priceRange) * chartHeight, 3, 0, 2 * Math.PI);
					ctx.fill();
					
				} catch (error) {
					console.error('Ошибка создания мини-графика:', error);
					miniChartContainer.style.display = 'none';
				}
			}

			getDateDaysAgo(days) {
				const date = new Date();
				date.setDate(date.getDate() - days);
				return date.toISOString().slice(0, 10);
			}

		}

		document.addEventListener('DOMContentLoaded', () => new PatternChart());
    </script>
</body>
</html>
